


SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;


COMMENT ON SCHEMA "public" IS 'standard public schema';



CREATE EXTENSION IF NOT EXISTS "pg_graphql" WITH SCHEMA "graphql";






CREATE EXTENSION IF NOT EXISTS "pg_stat_statements" WITH SCHEMA "extensions";






CREATE EXTENSION IF NOT EXISTS "pgcrypto" WITH SCHEMA "extensions";






CREATE EXTENSION IF NOT EXISTS "supabase_vault" WITH SCHEMA "vault";






CREATE EXTENSION IF NOT EXISTS "uuid-ossp" WITH SCHEMA "extensions";






CREATE TYPE "public"."us_entity_type_enum" AS ENUM (
    'C Corporation',
    'S Corporation',
    'LLC',
    'Partnership',
    'PC/PA',
    'PBC'
);


ALTER TYPE "public"."us_entity_type_enum" OWNER TO "postgres";


CREATE TYPE "public"."us_state_of_incorporation_enum" AS ENUM (
    'Alabama',
    'Alaska',
    'Arizona',
    'Wyoming',
    'District of Columbia'
);


ALTER TYPE "public"."us_state_of_incorporation_enum" OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."clear_unused_profile_fields"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  -- Clear corporation-specific fields unless US & Corporation
  IF NOT (NEW.region = 'United States' AND NEW.account_type = 'Corporation') THEN
    NEW.entity_type := NULL;
    NEW.state_of_incorporation := NULL;
  END IF;

  -- Clear income bracket unless region is Japan
  IF NEW.region <> 'Japan' THEN
    NEW.income_bracket := NULL;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."clear_unused_profile_fields"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."decrypt_secret"("enc_input" "bytea", "key_input" "text") RETURNS "text"
    LANGUAGE "sql" STABLE
    AS $$
  select pgp_sym_decrypt(enc_input, key_input);
$$;


ALTER FUNCTION "public"."decrypt_secret"("enc_input" "bytea", "key_input" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."encrypt_secret"("plain_input" "text", "key_input" "text") RETURNS "bytea"
    LANGUAGE "sql"
    AS $$
  select pgp_sym_encrypt(plain_input, key_input, 'cipher-algo=aes256');
$$;


ALTER FUNCTION "public"."encrypt_secret"("plain_input" "text", "key_input" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."fn_profiles_mirror_id_user_id"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
begin
  if NEW.user_id is null and NEW.id is not null then
    NEW.user_id := NEW.id;
  end if;

  if NEW.id is null and NEW.user_id is not null then
    NEW.id := NEW.user_id;
  end if;

  return NEW;
end;
$$;


ALTER FUNCTION "public"."fn_profiles_mirror_id_user_id"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_decrypted_connection"("p_user_id" "uuid", "p_exchange" "text") RETURNS TABLE("api_key" "text", "api_secret" "text")
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'decrypted', 'public'
    AS $$
BEGIN
  -- Vaultが提供する復号化済みビューの、正しい名前「decrypted.exchange_connections」を直接参照する。
  -- 私が勝手に追加していた「_decrypted」という接尾辞が、全ての元凶でした。
  RETURN QUERY
  SELECT
    v.api_key,
    v.api_secret
  FROM
    decrypted.exchange_connections AS v -- ここが「exchange_connections_decrypted」ではなく「exchange_connections」だった
  WHERE
    v.user_id = p_user_id AND v.exchange = p_exchange;
END;
$$;


ALTER FUNCTION "public"."get_decrypted_connection"("p_user_id" "uuid", "p_exchange" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."handle_new_user"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
BEGIN
  -- Insert a new row into public.profiles, copying the id and email
  -- from the newly created user in auth.users.
  INSERT INTO public.profiles (user_id, email)
  VALUES (new.id, new.email);
  RETURN new;
END;
$$;


ALTER FUNCTION "public"."handle_new_user"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."profiles_align_ids"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
    begin
      if NEW.user_id is null then
        raise exception 'profiles.user_id must not be null';
      end if;
      -- if id is null or not equal, align id to user_id for consistency
      if NEW.id is null or NEW.id <> NEW.user_id then
        NEW.id := NEW.user_id;
      end if;
      return NEW;
    end;
    $$;


ALTER FUNCTION "public"."profiles_align_ids"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."tg_invoices_set_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
    begin
      new.updated_at := now();
      return new;
    end
    $$;


ALTER FUNCTION "public"."tg_invoices_set_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_updated_at_column"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public'
    AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_updated_at_column"() OWNER TO "postgres";

SET default_tablespace = '';

SET default_table_access_method = "heap";


CREATE TABLE IF NOT EXISTS "public"."asset_prices" (
    "asset" "text" NOT NULL,
    "current_price" numeric NOT NULL,
    "last_updated" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."asset_prices" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."daily_exchange_rates" (
    "date" "date" NOT NULL,
    "source_currency" "text" NOT NULL,
    "target_currency" "text" NOT NULL,
    "rate" numeric NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."daily_exchange_rates" OWNER TO "postgres";


COMMENT ON TABLE "public"."daily_exchange_rates" IS 'Stores daily historical exchange rates for converting transaction values into a common currency like USD.';



COMMENT ON COLUMN "public"."daily_exchange_rates"."date" IS 'The specific date for which the exchange rate is valid.';



COMMENT ON COLUMN "public"."daily_exchange_rates"."source_currency" IS 'The original currency of the transaction (e.g., JPY, EUR).';



COMMENT ON COLUMN "public"."daily_exchange_rates"."target_currency" IS 'The target currency for conversion (e.g., USD).';



COMMENT ON COLUMN "public"."daily_exchange_rates"."rate" IS 'The market rate for converting one unit of the source currency into the target currency.';



CREATE TABLE IF NOT EXISTS "public"."exchange_trades" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "exchange" "text" NOT NULL,
    "symbol" "text" NOT NULL,
    "side" "text" NOT NULL,
    "amount" numeric NOT NULL,
    "price" numeric NOT NULL,
    "fee" numeric,
    "fee_currency" "text",
    "external_id" "text",
    "raw_data" "jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "trade_id" "text" NOT NULL,
    "fee_asset" "text",
    "ts" timestamp with time zone NOT NULL,
    "value_usd" numeric,
    "exchange_connection_id" bigint,
    "usage" "text",
    "note" "text"
);


ALTER TABLE "public"."exchange_trades" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."wallet_transactions" (
    "id" bigint NOT NULL,
    "user_id" "uuid" NOT NULL,
    "wallet_address" "text" NOT NULL,
    "chain_id" bigint DEFAULT 1 NOT NULL,
    "direction" "text" NOT NULL,
    "tx_hash" "text" NOT NULL,
    "block_number" bigint,
    "timestamp" timestamp with time zone,
    "from_address" "text",
    "to_address" "text",
    "value_wei" numeric,
    "asset_symbol" "text",
    "raw" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "asset_decimals" smallint DEFAULT 18,
    "price_usd" numeric,
    "fiat_value_usd" numeric,
    "occurred_at" timestamp with time zone,
    "usd_value_at_tx" numeric,
    "value_usd" numeric,
    "usage" "text",
    "note" "text",
    "amount" numeric
);


ALTER TABLE "public"."wallet_transactions" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."all_transactions" AS
 WITH "trades_with_acquisition_price" AS (
         SELECT "exchange_trades"."id",
            "exchange_trades"."user_id",
            "exchange_trades"."exchange",
            "exchange_trades"."symbol",
            "exchange_trades"."side",
            "exchange_trades"."amount",
            "exchange_trades"."price",
            "exchange_trades"."fee",
            "exchange_trades"."fee_currency",
            "exchange_trades"."external_id",
            "exchange_trades"."raw_data",
            "exchange_trades"."created_at",
            "exchange_trades"."updated_at",
            "exchange_trades"."trade_id",
            "exchange_trades"."fee_asset",
            "exchange_trades"."ts",
            "exchange_trades"."value_usd",
            "exchange_trades"."exchange_connection_id",
            "exchange_trades"."usage",
            "exchange_trades"."note",
            "split_part"("exchange_trades"."symbol", '/'::"text", 2) AS "quote_asset",
                CASE
                    WHEN ("exchange_trades"."side" = 'buy'::"text") THEN (("exchange_trades"."price" * "exchange_trades"."amount") + COALESCE("exchange_trades"."fee", (0)::numeric))
                    ELSE ("exchange_trades"."amount" - COALESCE("exchange_trades"."fee", (0)::numeric))
                END AS "acquisition_price_total"
           FROM "public"."exchange_trades"
          WHERE ("exchange_trades"."side" = ANY (ARRAY['buy'::"text", 'sell'::"text"]))
        )
 SELECT ('exchange-'::"text" || "et"."trade_id") AS "id",
    "et"."user_id",
    "et"."trade_id" AS "reference_id",
    "et"."ts" AS "date",
    ((((((('Exchange: '::"text" || "et"."side") || ' '::"text") || ("et"."amount")::"text") || ' '::"text") || "et"."symbol") || ' @ '::"text") || ("et"."price")::"text") AS "description",
        CASE
            WHEN ("et"."side" = 'sell'::"text") THEN ("et"."amount" / NULLIF("et"."price", (0)::numeric))
            ELSE "et"."amount"
        END AS "amount",
    "split_part"("et"."symbol", '/'::"text", 1) AS "asset",
    "et"."quote_asset",
    "et"."price",
    "et"."acquisition_price_total",
        CASE
            WHEN ("et"."quote_asset" = 'USD'::"text") THEN "et"."acquisition_price_total"
            ELSE ("et"."acquisition_price_total" * COALESCE("rates"."rate", (0)::numeric))
        END AS "value_in_usd",
    "et"."side" AS "type",
    'exchange'::"text" AS "source",
    "et"."exchange" AS "chain",
    "et"."usage",
    "et"."note"
   FROM ("trades_with_acquisition_price" "et"
     LEFT JOIN "public"."daily_exchange_rates" "rates" ON ((("date"("et"."ts") = "rates"."date") AND ("rates"."source_currency" = "et"."quote_asset") AND ("rates"."target_currency" = 'USD'::"text"))))
UNION ALL
 SELECT ('exchange-'::"text" || "et"."trade_id") AS "id",
    "et"."user_id",
    "et"."trade_id" AS "reference_id",
    "et"."ts" AS "date",
    ((((('Exchange: '::"text" || "et"."side") || ' '::"text") || ("et"."amount")::"text") || ' '::"text") || "et"."symbol") AS "description",
    "et"."amount",
    "et"."symbol" AS "asset",
    'USD'::"text" AS "quote_asset",
        CASE
            WHEN (("et"."amount" IS NOT NULL) AND ("et"."amount" <> (0)::numeric)) THEN (COALESCE("et"."value_usd", ("et"."amount" * "ap"."current_price")) / NULLIF("et"."amount", (0)::numeric))
            ELSE (0)::numeric
        END AS "price",
    COALESCE("et"."value_usd", ("et"."amount" * "ap"."current_price")) AS "acquisition_price_total",
    COALESCE("et"."value_usd", ("et"."amount" * "ap"."current_price")) AS "value_in_usd",
    "et"."side" AS "type",
    'exchange'::"text" AS "source",
    "et"."exchange" AS "chain",
    "et"."usage",
    "et"."note"
   FROM ("public"."exchange_trades" "et"
     LEFT JOIN "public"."asset_prices" "ap" ON (("et"."symbol" = "ap"."asset")))
  WHERE ("et"."side" = ANY (ARRAY['withdrawal'::"text", 'deposit'::"text"]))
UNION ALL
 SELECT ('onchain-'::"text" || "t"."id") AS "id",
    "t"."user_id",
    ("t"."id")::"text" AS "reference_id",
    "t"."timestamp" AS "date",
    ((('On-chain: '::"text" || "t"."direction") || ' '::"text") || COALESCE("t"."asset_symbol", 'ETH'::"text")) AS "description",
    ("t"."value_wei" / ('1000000000000000000'::bigint)::numeric) AS "amount",
    COALESCE("t"."asset_symbol", 'ETH'::"text") AS "asset",
    'USD'::"text" AS "quote_asset",
        CASE
            WHEN (("t"."value_wei" / ('1000000000000000000'::bigint)::numeric) <> (0)::numeric) THEN ("t"."value_usd" / NULLIF(("t"."value_wei" / ('1000000000000000000'::bigint)::numeric), (0)::numeric))
            ELSE (0)::numeric
        END AS "price",
    "t"."value_usd" AS "acquisition_price_total",
    "t"."value_usd" AS "value_in_usd",
    "t"."direction" AS "type",
    'on-chain'::"text" AS "source",
    ("t"."chain_id")::"text" AS "chain",
    "t"."usage",
    "t"."note"
   FROM "public"."wallet_transactions" "t";


ALTER VIEW "public"."all_transactions" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."audit_logs" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid",
    "action" "text" NOT NULL,
    "resource_type" "text",
    "resource_id" "text",
    "ip_address" "inet",
    "user_agent" "text",
    "metadata" "jsonb",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."audit_logs" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."clients" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "name" "text" NOT NULL,
    "address" "text",
    "country" "text",
    "email" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "wallet" "text"
);


ALTER TABLE "public"."clients" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."companies" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "name" "text" NOT NULL,
    "address" "text",
    "country" "text",
    "tax_id" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "email" "text"
);


ALTER TABLE "public"."companies" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."crypto_payments" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "invoice_id" "text",
    "recipient_address" "text" NOT NULL,
    "amount" numeric(20,8) NOT NULL,
    "currency" "text" NOT NULL,
    "usd_amount" numeric(20,2),
    "payment_status" "text" DEFAULT 'pending'::"text",
    "transaction_hash" "text",
    "wallet_address" "text",
    "gas_fee" numeric(20,8),
    "description" "text",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."crypto_payments" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."customers" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "name" "text" NOT NULL,
    "email" "text",
    "company" "text",
    "address" "text",
    "deleted_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."customers" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."exchange_accounts" (
    "id" bigint NOT NULL,
    "connection_id" bigint,
    "account_uid" "text" NOT NULL,
    "type" "text"
);


ALTER TABLE "public"."exchange_accounts" OWNER TO "postgres";


ALTER TABLE "public"."exchange_accounts" ALTER COLUMN "id" ADD GENERATED ALWAYS AS IDENTITY (
    SEQUENCE NAME "public"."exchange_accounts_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);



CREATE TABLE IF NOT EXISTS "public"."exchange_api_credentials" (
    "id" bigint NOT NULL,
    "user_id" "uuid" NOT NULL,
    "exchange" "text" NOT NULL,
    "external_user_id" "text",
    "enc_blob" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "exchange_api_credentials_exchange_check" CHECK (("exchange" = ANY (ARRAY['binance'::"text", 'bybit'::"text", 'okx'::"text"])))
);


ALTER TABLE "public"."exchange_api_credentials" OWNER TO "postgres";


CREATE SEQUENCE IF NOT EXISTS "public"."exchange_api_credentials_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."exchange_api_credentials_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."exchange_api_credentials_id_seq" OWNED BY "public"."exchange_api_credentials"."id";



CREATE TABLE IF NOT EXISTS "public"."exchange_balances" (
    "id" bigint NOT NULL,
    "account_id" bigint,
    "asset" "text" NOT NULL,
    "free" numeric,
    "locked" numeric,
    "total" numeric,
    "at" timestamp with time zone NOT NULL
);


ALTER TABLE "public"."exchange_balances" OWNER TO "postgres";


ALTER TABLE "public"."exchange_balances" ALTER COLUMN "id" ADD GENERATED ALWAYS AS IDENTITY (
    SEQUENCE NAME "public"."exchange_balances_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);



CREATE TABLE IF NOT EXISTS "public"."exchange_connections" (
    "id" bigint NOT NULL,
    "user_id" "uuid" NOT NULL,
    "exchange" "text" NOT NULL,
    "label" "text",
    "api_key" "text",
    "api_secret" "text",
    "oauth_provider" "text",
    "oauth_access_token" "text",
    "oauth_refresh_token" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "external_user_id" "text",
    "status" "text" DEFAULT 'linked'::"text",
    "connection_name" "text" NOT NULL,
    "encrypted_blob" "text"
);


ALTER TABLE "public"."exchange_connections" OWNER TO "postgres";


ALTER TABLE "public"."exchange_connections" ALTER COLUMN "id" ADD GENERATED ALWAYS AS IDENTITY (
    SEQUENCE NAME "public"."exchange_connections_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);



CREATE TABLE IF NOT EXISTS "public"."exchange_trade_values" (
    "exchange_trade_id" "text" NOT NULL,
    "user_id" "uuid" NOT NULL,
    "asset" "text",
    "symbol" "text",
    "base_amount" numeric,
    "price_usd" numeric,
    "fiat_value_usd" numeric,
    "fee" numeric,
    "fee_asset" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."exchange_trade_values" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."exchange_transfers" (
    "id" bigint NOT NULL,
    "account_id" bigint,
    "direction" "text",
    "asset" "text" NOT NULL,
    "amount" numeric NOT NULL,
    "txid" "text",
    "network" "text",
    "occurred_at" timestamp with time zone NOT NULL,
    "raw" "jsonb",
    CONSTRAINT "exchange_transfers_direction_check" CHECK (("direction" = ANY (ARRAY['deposit'::"text", 'withdraw'::"text"])))
);


ALTER TABLE "public"."exchange_transfers" OWNER TO "postgres";


ALTER TABLE "public"."exchange_transfers" ALTER COLUMN "id" ADD GENERATED ALWAYS AS IDENTITY (
    SEQUENCE NAME "public"."exchange_transfers_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);



CREATE OR REPLACE VIEW "public"."wallet_tx_norm" AS
 SELECT "id",
    "user_id",
    (("to_jsonb"("t".*) ->> 'chain_id'::"text"))::integer AS "chain_id",
    "lower"(COALESCE(("to_jsonb"("t".*) ->> 'direction'::"text"), ''::"text")) AS "direction",
    "lower"(COALESCE(("to_jsonb"("t".*) ->> 'wallet_address'::"text"), ("to_jsonb"("t".*) ->> 'from'::"text"), ("to_jsonb"("t".*) ->> 'from_address'::"text"))) AS "wallet_address",
    "lower"(COALESCE(("to_jsonb"("t".*) ->> 'counterparty_address'::"text"), ("to_jsonb"("t".*) ->> 'to'::"text"), ("to_jsonb"("t".*) ->> 'to_address'::"text"))) AS "counterparty_address",
    COALESCE((NULLIF(("to_jsonb"("t".*) ->> 'amount'::"text"), ''::"text"))::numeric, (NULLIF(("to_jsonb"("t".*) ->> 'value'::"text"), ''::"text"))::numeric, (NULLIF(("to_jsonb"("t".*) ->> 'qty'::"text"), ''::"text"))::numeric, (0)::numeric) AS "amount",
    COALESCE((NULLIF(("to_jsonb"("t".*) ->> 'occurred_at'::"text"), ''::"text"))::timestamp with time zone, (NULLIF(("to_jsonb"("t".*) ->> 'block_time'::"text"), ''::"text"))::timestamp with time zone, (NULLIF(("to_jsonb"("t".*) ->> 'timestamp'::"text"), ''::"text"))::timestamp with time zone, (NULLIF(("to_jsonb"("t".*) ->> 'created_at'::"text"), ''::"text"))::timestamp with time zone, "now"()) AS "occurred_at",
    COALESCE(("to_jsonb"("t".*) ->> 'tx_hash'::"text"), ("to_jsonb"("t".*) ->> 'transaction_hash'::"text"), ("to_jsonb"("t".*) ->> 'hash'::"text")) AS "tx_hash"
   FROM "public"."wallet_transactions" "t";


ALTER VIEW "public"."wallet_tx_norm" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."internal_transfer_candidates" AS
 SELECT "o"."id" AS "out_tx_id",
    "i"."id" AS "in_tx_id",
    "o"."user_id",
    "o"."chain_id",
    "abs"(("o"."amount" - "i"."amount")) AS "amount_delta",
        CASE
            WHEN (GREATEST("o"."amount", "i"."amount") = (0)::numeric) THEN (0)::numeric
            ELSE ("abs"(("o"."amount" - "i"."amount")) / GREATEST("o"."amount", "i"."amount"))
        END AS "amount_delta_rate",
    "abs"(EXTRACT(epoch FROM ("i"."occurred_at" - "o"."occurred_at"))) AS "diff_seconds",
        CASE
            WHEN (("o"."tx_hash" IS NOT NULL) AND ("o"."tx_hash" = "i"."tx_hash")) THEN 'same_tx_hash'::"text"
            WHEN (("o"."counterparty_address" IS NOT NULL) AND ("o"."counterparty_address" = "i"."wallet_address")) THEN 'out->in_addr_match'::"text"
            WHEN (("i"."counterparty_address" IS NOT NULL) AND ("i"."counterparty_address" = "o"."wallet_address")) THEN 'in->out_addr_match'::"text"
            ELSE 'amount_time_heuristic'::"text"
        END AS "reason"
   FROM ("public"."wallet_tx_norm" "o"
     JOIN "public"."wallet_tx_norm" "i" ON ((("o"."user_id" = "i"."user_id") AND (("o"."chain_id" IS NULL) OR ("i"."chain_id" IS NULL) OR ("o"."chain_id" = "i"."chain_id")) AND (COALESCE("o"."direction", ''::"text") ~~ 'out%'::"text") AND (COALESCE("i"."direction", ''::"text") ~~ 'in%'::"text") AND (("abs"(("o"."amount" - "i"."amount")) <= 0.000001) OR (
        CASE
            WHEN (GREATEST("o"."amount", "i"."amount") = (0)::numeric) THEN (0)::numeric
            ELSE ("abs"(("o"."amount" - "i"."amount")) / GREATEST("o"."amount", "i"."amount"))
        END <= 0.005)) AND ("abs"(EXTRACT(epoch FROM ("i"."occurred_at" - "o"."occurred_at"))) <= (7200)::numeric) AND ("o"."id" <> "i"."id"))));


ALTER VIEW "public"."internal_transfer_candidates" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."internal_transfer_links" (
    "id" bigint NOT NULL,
    "out_tx_id" bigint NOT NULL,
    "in_tx_id" bigint NOT NULL,
    "reason" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."internal_transfer_links" OWNER TO "postgres";


CREATE SEQUENCE IF NOT EXISTS "public"."internal_transfer_links_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."internal_transfer_links_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."internal_transfer_links_id_seq" OWNED BY "public"."internal_transfer_links"."id";



CREATE OR REPLACE VIEW "public"."v_all_transactions_classified" AS
 SELECT "id",
    "user_id",
    "reference_id",
    "date",
    "description",
    "amount",
    "asset",
    "quote_asset",
    "price",
    "acquisition_price_total",
    "value_in_usd",
    "type",
    "source",
    "chain",
    "usage",
    "note",
        CASE
            WHEN ("type" = ANY (ARRAY['buy'::"text", 'sell'::"text"])) THEN "upper"("type")
            WHEN (("type" ~~* 'deposit%'::"text") OR ("type" ~~* 'receive%'::"text") OR ("type" = 'IN'::"text")) THEN 'DEPOSIT'::"text"
            WHEN (("type" ~~* 'withdraw%'::"text") OR ("type" ~~* 'send%'::"text") OR ("type" = 'OUT'::"text")) THEN 'WITHDRAWAL'::"text"
            ELSE 'OTHER'::"text"
        END AS "transaction_type"
   FROM "public"."all_transactions" "t";


ALTER VIEW "public"."v_all_transactions_classified" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."internal_transfer_pairs" AS
 WITH "ranked_matches" AS (
         SELECT "w"."id" AS "withdrawal_id",
            "d"."id" AS "deposit_id",
            "row_number"() OVER (PARTITION BY "w"."id" ORDER BY ("d"."date" - "w"."date")) AS "w_rank",
            "row_number"() OVER (PARTITION BY "d"."id" ORDER BY ("d"."date" - "w"."date")) AS "d_rank"
           FROM (( SELECT "v_all_transactions_classified"."id",
                    "v_all_transactions_classified"."user_id",
                    "v_all_transactions_classified"."reference_id",
                    "v_all_transactions_classified"."date",
                    "v_all_transactions_classified"."description",
                    "v_all_transactions_classified"."amount",
                    "v_all_transactions_classified"."asset",
                    "v_all_transactions_classified"."quote_asset",
                    "v_all_transactions_classified"."price",
                    "v_all_transactions_classified"."acquisition_price_total",
                    "v_all_transactions_classified"."value_in_usd",
                    "v_all_transactions_classified"."type",
                    "v_all_transactions_classified"."source",
                    "v_all_transactions_classified"."chain",
                    "v_all_transactions_classified"."usage",
                    "v_all_transactions_classified"."note",
                    "v_all_transactions_classified"."transaction_type"
                   FROM "public"."v_all_transactions_classified"
                  WHERE ("v_all_transactions_classified"."transaction_type" = 'WITHDRAWAL'::"text")) "w"
             JOIN ( SELECT "v_all_transactions_classified"."id",
                    "v_all_transactions_classified"."user_id",
                    "v_all_transactions_classified"."reference_id",
                    "v_all_transactions_classified"."date",
                    "v_all_transactions_classified"."description",
                    "v_all_transactions_classified"."amount",
                    "v_all_transactions_classified"."asset",
                    "v_all_transactions_classified"."quote_asset",
                    "v_all_transactions_classified"."price",
                    "v_all_transactions_classified"."acquisition_price_total",
                    "v_all_transactions_classified"."value_in_usd",
                    "v_all_transactions_classified"."type",
                    "v_all_transactions_classified"."source",
                    "v_all_transactions_classified"."chain",
                    "v_all_transactions_classified"."usage",
                    "v_all_transactions_classified"."note",
                    "v_all_transactions_classified"."transaction_type"
                   FROM "public"."v_all_transactions_classified"
                  WHERE ("v_all_transactions_classified"."transaction_type" = 'DEPOSIT'::"text")) "d" ON ((("w"."user_id" = "d"."user_id") AND ("w"."asset" = "d"."asset") AND ("d"."date" > "w"."date") AND ("d"."date" <= ("w"."date" + '2 days'::interval)) AND (("abs"(("w"."amount" - "d"."amount")) / NULLIF("w"."amount", (0)::numeric)) <= 0.002))))
        )
 SELECT "ranked_matches"."withdrawal_id" AS "id"
   FROM "ranked_matches"
  WHERE (("ranked_matches"."w_rank" = 1) AND ("ranked_matches"."d_rank" = 1))
UNION
 SELECT "ranked_matches"."deposit_id" AS "id"
   FROM "ranked_matches"
  WHERE (("ranked_matches"."w_rank" = 1) AND ("ranked_matches"."d_rank" = 1));


ALTER VIEW "public"."internal_transfer_pairs" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."invoices" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "customer_id" "uuid",
    "invoice_number" "text" NOT NULL,
    "amount" numeric NOT NULL,
    "currency" "text" DEFAULT 'USD'::"text" NOT NULL,
    "status" "text" DEFAULT 'unpaid'::"text" NOT NULL,
    "memo" "text",
    "due_date" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "company_id" "uuid",
    "client_id" "uuid",
    "customer_name" "text",
    "items" "jsonb",
    "issue_date" "date" DEFAULT CURRENT_DATE,
    "notes" "text",
    "tax_rate" numeric(5,2),
    "billing_address" "text",
    "company_address" "text",
    "company_wallet_address" "text",
    "number" "text",
    "subtotal" numeric,
    "tax" numeric,
    "total" numeric
);


ALTER TABLE "public"."invoices" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."journal_entries" (
    "id" bigint NOT NULL,
    "user_id" "uuid" NOT NULL,
    "tx_id" bigint,
    "entry_date" "date" NOT NULL,
    "account" "text" NOT NULL,
    "dc" character(1) NOT NULL,
    "amount" numeric(78,18) NOT NULL,
    "currency" "text" DEFAULT 'USD'::"text" NOT NULL,
    "memo" "text"
);


ALTER TABLE "public"."journal_entries" OWNER TO "postgres";


CREATE SEQUENCE IF NOT EXISTS "public"."journal_entries_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."journal_entries_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."journal_entries_id_seq" OWNED BY "public"."journal_entries"."id";



CREATE TABLE IF NOT EXISTS "public"."journal_lines" (
    "id" bigint NOT NULL,
    "entry_id" bigint NOT NULL,
    "account_code" "text" NOT NULL,
    "debit" numeric DEFAULT 0 NOT NULL,
    "credit" numeric DEFAULT 0 NOT NULL,
    "meta" "jsonb",
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."journal_lines" OWNER TO "postgres";


CREATE SEQUENCE IF NOT EXISTS "public"."journal_lines_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."journal_lines_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."journal_lines_id_seq" OWNED BY "public"."journal_lines"."id";



CREATE TABLE IF NOT EXISTS "public"."meter_events" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "event_type" "text" NOT NULL,
    "amount" numeric,
    "currency" "text",
    "cost" numeric NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."meter_events" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."payment_links" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "title" "text",
    "amount" numeric,
    "currency" "text",
    "status" "text",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."payment_links" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."payment_merchants" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "store_name" "text",
    "default_currency" "text",
    "allowed_networks" "text"[],
    "webhook_secret" "text",
    "webhook_url" "text",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."payment_merchants" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."payment_vault_addresses" (
    "id" bigint NOT NULL,
    "user_id" "uuid" NOT NULL,
    "network" "text" NOT NULL,
    "asset" "text" NOT NULL,
    "address" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."payment_vault_addresses" OWNER TO "postgres";


CREATE SEQUENCE IF NOT EXISTS "public"."payment_vault_addresses_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."payment_vault_addresses_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."payment_vault_addresses_id_seq" OWNED BY "public"."payment_vault_addresses"."id";



CREATE TABLE IF NOT EXISTS "public"."profiles" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "display_name" "text",
    "email" "text",
    "avatar_url" "text",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "tax_country" "text",
    "entity_type" "text",
    "seats_limit" integer DEFAULT 1,
    "plan_type" "text" DEFAULT 'individual_free'::"text",
    "account_type" "text" DEFAULT 'individual'::"text",
    "primary_wallet" "text",
    "verify_nonce" "text",
    "country" "text",
    "gateway_enabled" boolean DEFAULT false,
    "state_of_incorporation" "text",
    "income_bracket" "text",
    "us_entity_type" "text",
    "us_state_of_incorporation" "text",
    "region" "text"
);


ALTER TABLE "public"."profiles" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."transaction_purposes" (
    "user_id" "uuid" NOT NULL,
    "source" "text" NOT NULL,
    "source_id" "text" NOT NULL,
    "purpose" "text" NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "transaction_purposes_source_check" CHECK (("source" = ANY (ARRAY['wallet'::"text", 'exchange'::"text"])))
);


ALTER TABLE "public"."transaction_purposes" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."transaction_usage_labels" (
    "id" bigint NOT NULL,
    "user_id" "uuid" NOT NULL,
    "tx_id" bigint,
    "ctx_id" "text",
    "usage_key" "text",
    "confidence" numeric,
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."transaction_usage_labels" OWNER TO "postgres";


CREATE SEQUENCE IF NOT EXISTS "public"."transaction_usage_labels_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."transaction_usage_labels_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."transaction_usage_labels_id_seq" OWNED BY "public"."transaction_usage_labels"."id";



CREATE TABLE IF NOT EXISTS "public"."transaction_usage_predictions" (
    "user_id" "uuid" NOT NULL,
    "tx_id" bigint NOT NULL,
    "model" "text" DEFAULT 'rule'::"text" NOT NULL,
    "label" "text" NOT NULL,
    "score" numeric(6,5) DEFAULT 1.0 NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."transaction_usage_predictions" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."transaction_usages" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid",
    "source_type" "text",
    "source_id" "text" NOT NULL,
    "usage_predicted" "text",
    "usage_manual" "text",
    "confidence" numeric,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "transaction_usages_source_type_check" CHECK (("source_type" = ANY (ARRAY['wallet'::"text", 'exchange'::"text"])))
);


ALTER TABLE "public"."transaction_usages" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."transactions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "wallet_address" "text" NOT NULL,
    "transaction_hash" "text" NOT NULL,
    "transaction_type" "text" NOT NULL,
    "amount" numeric(20,8) NOT NULL,
    "currency" "text" NOT NULL,
    "usd_value" numeric(20,2),
    "from_address" "text",
    "to_address" "text",
    "gas_fee" numeric(20,8),
    "gas_fee_usd" numeric(20,2),
    "block_number" bigint,
    "transaction_status" "text" DEFAULT 'pending'::"text",
    "blockchain_network" "text" NOT NULL,
    "transaction_date" timestamp with time zone NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "chain_id" integer,
    "network" "text",
    "log_index" integer DEFAULT 0,
    "direction" "text",
    "type" "text",
    "asset_contract" "text",
    "asset_symbol" "text",
    "asset_decimals" integer,
    "fee_native" numeric,
    "usd_value_at_tx" numeric,
    "usd_fee_at_tx" numeric,
    "price_source" "text",
    "inserted_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "transactions_direction_check" CHECK (("direction" = ANY (ARRAY['in'::"text", 'out'::"text", 'self'::"text"]))),
    CONSTRAINT "transactions_type_check" CHECK (("type" = ANY (ARRAY['native'::"text", 'erc20'::"text", 'erc721'::"text", 'erc1155'::"text", 'swap'::"text", 'bridge'::"text", 'fee'::"text", 'other'::"text"])))
);


ALTER TABLE "public"."transactions" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."transfer_links" (
    "id" bigint NOT NULL,
    "user_id" "uuid" NOT NULL,
    "wallet_tx_id" bigint NOT NULL,
    "exchange_transfer_id" bigint NOT NULL,
    "confidence" real NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."transfer_links" OWNER TO "postgres";


ALTER TABLE "public"."transfer_links" ALTER COLUMN "id" ADD GENERATED ALWAYS AS IDENTITY (
    SEQUENCE NAME "public"."transfer_links_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);



CREATE TABLE IF NOT EXISTS "public"."transfers" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "user_id" "uuid",
    "client_id" "uuid",
    "invoice_id" "uuid",
    "wallet_address" "text" NOT NULL,
    "amount" numeric NOT NULL,
    "currency" "text" DEFAULT 'ETH'::"text",
    "status" "text" DEFAULT 'pending'::"text",
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."transfers" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."usage_categories" (
    "key" "text" NOT NULL,
    "ifrs_standard" "text",
    "description" "text"
);


ALTER TABLE "public"."usage_categories" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."user_monthly_counters" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "month_year" "text" NOT NULL,
    "event_count" integer DEFAULT 0,
    "total_cost" numeric DEFAULT 0,
    "bundles_used" integer DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."user_monthly_counters" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."user_sessions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "ip_address" "inet",
    "user_agent" "text",
    "device_fingerprint" "text",
    "first_seen" timestamp with time zone DEFAULT "now"() NOT NULL,
    "last_seen" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."user_sessions" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."wallet_connections" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "wallet_address" "text" NOT NULL,
    "wallet_type" "text" NOT NULL,
    "wallet_name" "text",
    "is_primary" boolean DEFAULT false,
    "balance_usd" numeric(20,8) DEFAULT 0,
    "last_sync_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "verification_status" "text" DEFAULT 'unverified'::"text",
    "verified_at" timestamp with time zone,
    "verification_signature" "text",
    "chain_last_synced_at" "jsonb" DEFAULT '{}'::"jsonb",
    "chain" "text"
);


ALTER TABLE "public"."wallet_connections" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_all_transactions" AS
 WITH "user_connections" AS (
         SELECT "wallet_connections"."user_id",
            "wallet_connections"."wallet_address" AS "connection_identifier",
            'wallet'::"text" AS "connection_type"
           FROM "public"."wallet_connections"
        UNION ALL
         SELECT "exchange_connections"."user_id",
            ("exchange_connections"."id")::"text" AS "connection_identifier",
            'exchange'::"text" AS "connection_type"
           FROM "public"."exchange_connections"
        ), "all_combined_txs" AS (
         SELECT ("t"."id")::"text" AS "id",
            "t"."user_id",
            "t"."tx_hash" AS "reference_id",
            "t"."timestamp" AS "date",
            ("t"."value_wei" / '1000000000000000000'::numeric) AS "amount",
            COALESCE("t"."asset_symbol", 'UNKNOWN_ASSET'::"text") AS "asset",
            ("t"."chain_id")::"text" AS "chain",
                CASE
                    WHEN (("t"."direction" = 'in'::"text") AND ("t"."from_address" IN ( SELECT "uc"."connection_identifier"
                       FROM "user_connections" "uc"
                      WHERE ("uc"."user_id" = "t"."user_id")))) THEN 'internal_transfer'::"text"
                    WHEN (("t"."direction" = 'out'::"text") AND ("t"."to_address" IN ( SELECT "uc"."connection_identifier"
                       FROM "user_connections" "uc"
                      WHERE ("uc"."user_id" = "t"."user_id")))) THEN 'internal_transfer'::"text"
                    ELSE "t"."direction"
                END AS "type",
            NULL::numeric AS "acquisition_price_total",
            NULL::"text" AS "quote_asset",
            "t"."value_usd" AS "value_in_usd",
                CASE
                    WHEN ((("t"."value_wei" / '1000000000000000000'::numeric) > (0)::numeric) AND ("t"."value_usd" IS NOT NULL)) THEN ("t"."value_usd" / ("t"."value_wei" / '1000000000000000000'::numeric))
                    ELSE NULL::numeric
                END AS "price"
           FROM "public"."wallet_transactions" "t"
        UNION ALL
         SELECT "et"."trade_id" AS "id",
            "et"."user_id",
            "et"."trade_id" AS "reference_id",
            "et"."ts" AS "date",
                CASE
                    WHEN ("et"."side" = 'sell'::"text") THEN "et"."fee"
                    ELSE "et"."amount"
                END AS "amount",
            "split_part"("et"."symbol", '/'::"text", 1) AS "asset",
            "et"."exchange" AS "chain",
            "et"."side" AS "type",
                CASE
                    WHEN ("et"."side" = 'sell'::"text") THEN "et"."amount"
                    ELSE "et"."fee"
                END AS "acquisition_price_total",
            "split_part"("et"."symbol", '/'::"text", 2) AS "quote_asset",
            "et"."value_usd" AS "value_in_usd",
            "et"."price"
           FROM "public"."exchange_trades" "et"
          WHERE ("et"."side" = ANY (ARRAY['buy'::"text", 'sell'::"text"]))
        UNION ALL
         SELECT "et"."trade_id" AS "id",
            "et"."user_id",
            "et"."trade_id" AS "reference_id",
            "et"."ts" AS "date",
            "et"."amount",
            "et"."symbol" AS "asset",
            "et"."exchange" AS "chain",
                CASE
                    WHEN (("et"."side" = 'withdrawal'::"text") AND (("et"."raw_data" ->> 'address'::"text") IN ( SELECT "uc"."connection_identifier"
                       FROM "user_connections" "uc"
                      WHERE ("uc"."user_id" = "et"."user_id")))) THEN 'internal_transfer'::"text"
                    WHEN (("et"."side" = 'deposit'::"text") AND (("et"."raw_data" ->> 'address'::"text") IN ( SELECT "uc"."connection_identifier"
                       FROM "user_connections" "uc"
                      WHERE ("uc"."user_id" = "et"."user_id")))) THEN 'internal_transfer'::"text"
                    ELSE "et"."side"
                END AS "type",
            NULL::numeric AS "acquisition_price_total",
            NULL::"text" AS "quote_asset",
            COALESCE(NULLIF("et"."value_usd", (0)::numeric), ("et"."amount" * ( SELECT "r"."rate"
                   FROM "public"."daily_exchange_rates" "r"
                  WHERE (("r"."source_currency" = "et"."symbol") AND ("r"."target_currency" = 'USD'::"text") AND ("r"."date" <= "date"("et"."ts")))
                  ORDER BY "r"."date" DESC
                 LIMIT 1))) AS "value_in_usd",
            COALESCE(NULLIF("et"."price", (0)::numeric), ( SELECT "r"."rate"
                   FROM "public"."daily_exchange_rates" "r"
                  WHERE (("r"."source_currency" = "et"."symbol") AND ("r"."target_currency" = 'USD'::"text") AND ("r"."date" <= "date"("et"."ts")))
                  ORDER BY "r"."date" DESC
                 LIMIT 1)) AS "price"
           FROM "public"."exchange_trades" "et"
          WHERE ("et"."side" = ANY (ARRAY['withdrawal'::"text", 'deposit'::"text"]))
        )
 SELECT "id",
    "user_id",
    "reference_id",
    "date",
    (((("type" || ' '::"text") || ("amount")::"text") || ' '::"text") || "asset") AS "description",
    "amount",
    "asset",
    "quote_asset",
    "price",
    "acquisition_price_total",
    "value_in_usd",
    "type",
        CASE
            WHEN ("chain" ~ '^[0-9\.]+$'::"text") THEN 'on-chain'::"text"
            ELSE 'exchange'::"text"
        END AS "source",
    "chain",
        CASE
            WHEN ("type" = 'internal_transfer'::"text") THEN 'internal_transfer'::"text"
            ELSE NULL::"text"
        END AS "usage",
    NULL::"text" AS "note"
   FROM "all_combined_txs";


ALTER VIEW "public"."v_all_transactions" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_profit_loss_statement" AS
 WITH "pnl_items" AS (
         SELECT "all_transactions"."user_id",
            'Sales Revenue (IAS 2)'::"text" AS "account",
            "all_transactions"."value_in_usd" AS "balance"
           FROM "public"."all_transactions"
          WHERE (("all_transactions"."usage" = 'sale_ias2'::"text") AND ("all_transactions"."value_in_usd" IS NOT NULL))
        UNION ALL
         SELECT "all_transactions"."user_id",
            'Consideration Revenue (IFRS 15)'::"text" AS "text",
            "all_transactions"."value_in_usd"
           FROM "public"."all_transactions"
          WHERE (("all_transactions"."usage" = 'revenue_ifrs15'::"text") AND ("all_transactions"."value_in_usd" IS NOT NULL))
        UNION ALL
         SELECT "all_transactions"."user_id",
            'Staking & Mining Rewards'::"text" AS "text",
            "all_transactions"."value_in_usd"
           FROM "public"."all_transactions"
          WHERE (("all_transactions"."usage" = ANY (ARRAY['mining_rewards'::"text", 'staking_rewards'::"text"])) AND ("all_transactions"."value_in_usd" IS NOT NULL))
        UNION ALL
         SELECT "all_transactions"."user_id",
            'Cost of Goods Sold (IAS 2)'::"text" AS "text",
            (- "all_transactions"."value_in_usd")
           FROM "public"."all_transactions"
          WHERE ("all_transactions"."usage" = 'sale_ias2'::"text")
        UNION ALL
         SELECT "all_transactions"."user_id",
            'Unrealized Gains on Intangibles (Revaluation)'::"text" AS "text",
            "all_transactions"."value_in_usd"
           FROM "public"."all_transactions"
          WHERE ("all_transactions"."usage" = 'revaluation_increase_ias38'::"text")
        UNION ALL
         SELECT "all_transactions"."user_id",
            'Unrealized Losses on Intangibles (Impairment)'::"text" AS "text",
            (- "all_transactions"."value_in_usd")
           FROM "public"."all_transactions"
          WHERE ("all_transactions"."usage" = ANY (ARRAY['impairment_ias38'::"text", 'revaluation_decrease_ias38'::"text"]))
        UNION ALL
         SELECT "all_transactions"."user_id",
            'Realized Gains on Intangibles (Sale)'::"text" AS "text",
            0
           FROM "public"."all_transactions"
          WHERE ("all_transactions"."usage" = 'sale_ias38'::"text")
        UNION ALL
         SELECT "all_transactions"."user_id",
            'Gas & Network Fees'::"text" AS "text",
            (- "all_transactions"."value_in_usd")
           FROM "public"."all_transactions"
          WHERE (("all_transactions"."usage" = 'gas_fees'::"text") AND ("all_transactions"."value_in_usd" IS NOT NULL))
        UNION ALL
         SELECT "all_transactions"."user_id",
            'Loss of Crypto (Unrecoverable)'::"text" AS "text",
            (- "all_transactions"."value_in_usd")
           FROM "public"."all_transactions"
          WHERE (("all_transactions"."usage" = 'loss_unrecoverable'::"text") AND ("all_transactions"."value_in_usd" IS NOT NULL))
        )
 SELECT "user_id",
    "account",
    "sum"("balance") AS "balance"
   FROM "pnl_items"
  WHERE (("user_id" IS NOT NULL) AND ("balance" IS NOT NULL))
  GROUP BY "user_id", "account"
  ORDER BY "user_id", "account";


ALTER VIEW "public"."v_profit_loss_statement" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_balance_sheet" AS
 WITH "account_movements" AS (
         SELECT "all_transactions"."user_id",
            'Intangible Assets (Investing Crypto)'::"text" AS "account",
            "sum"("all_transactions"."value_in_usd") AS "balance_change"
           FROM "public"."all_transactions"
          WHERE ("all_transactions"."usage" = ANY (ARRAY['investment_acquisition_ias38'::"text", 'mining_rewards'::"text", 'staking_rewards'::"text", 'revenue_ifrs15'::"text", 'revaluation_increase_ias38'::"text", 'crypto_to_crypto_exchange'::"text"]))
          GROUP BY "all_transactions"."user_id"
        UNION ALL
         SELECT "all_transactions"."user_id",
            'Inventory (Trading Crypto)'::"text" AS "text",
            "sum"("all_transactions"."value_in_usd") AS "sum"
           FROM "public"."all_transactions"
          WHERE ("all_transactions"."usage" = 'trading_acquisition_ias2'::"text")
          GROUP BY "all_transactions"."user_id"
        UNION ALL
         SELECT "all_transactions"."user_id",
            'Intangible Assets (Investing Crypto)'::"text" AS "text",
            "sum"((- "all_transactions"."value_in_usd")) AS "sum"
           FROM "public"."all_transactions"
          WHERE ("all_transactions"."usage" = ANY (ARRAY['sale_ias38'::"text", 'impairment_ias38'::"text", 'loss_unrecoverable'::"text", 'revaluation_decrease_ias38'::"text", 'gas_fees'::"text"]))
          GROUP BY "all_transactions"."user_id"
        UNION ALL
         SELECT "all_transactions"."user_id",
            'Inventory (Trading Crypto)'::"text" AS "text",
            "sum"((- "all_transactions"."value_in_usd")) AS "sum"
           FROM "public"."all_transactions"
          WHERE ("all_transactions"."usage" = ANY (ARRAY['sale_ias2'::"text", 'lcnrv_ias2'::"text"]))
          GROUP BY "all_transactions"."user_id"
        UNION ALL
         SELECT "all_transactions"."user_id",
            'Cash & Cash Equivalents'::"text" AS "text",
            "sum"("all_transactions"."value_in_usd") AS "sum"
           FROM "public"."all_transactions"
          WHERE ("all_transactions"."usage" = ANY (ARRAY['sale_ias38'::"text", 'sale_ias2'::"text"]))
          GROUP BY "all_transactions"."user_id"
        UNION ALL
         SELECT "all_transactions"."user_id",
            'Cash & Cash Equivalents'::"text" AS "text",
            "sum"((- "all_transactions"."value_in_usd")) AS "sum"
           FROM "public"."all_transactions"
          WHERE ("all_transactions"."usage" = ANY (ARRAY['investment_acquisition_ias38'::"text", 'trading_acquisition_ias2'::"text", 'crypto_to_crypto_exchange'::"text"]))
          GROUP BY "all_transactions"."user_id"
        UNION ALL
         SELECT "p"."user_id",
            'Retained Earnings'::"text" AS "text",
            "sum"("p"."balance") AS "sum"
           FROM "public"."v_profit_loss_statement" "p"
          WHERE ("p"."account" <> 'Unrealized Gains on Intangibles (Revaluation)'::"text")
          GROUP BY "p"."user_id"
        UNION ALL
         SELECT "p"."user_id",
            'Revaluation Surplus'::"text" AS "text",
            "sum"("p"."balance") AS "sum"
           FROM "public"."v_profit_loss_statement" "p"
          WHERE ("p"."account" = 'Unrealized Gains on Intangibles (Revaluation)'::"text")
          GROUP BY "p"."user_id"
        )
 SELECT "user_id",
    "account",
    "sum"("balance_change") AS "balance"
   FROM "account_movements" "m"
  WHERE (("account" IS NOT NULL) AND ("balance_change" IS NOT NULL))
  GROUP BY "user_id", "account"
  ORDER BY "user_id", "account";


ALTER VIEW "public"."v_balance_sheet" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_cash_flow_statement" AS
 WITH "cash_flows" AS (
         SELECT "all_transactions"."user_id",
            'Inflow from Sales (IAS 2 & IFRS 15)'::"text" AS "item",
            "sum"("all_transactions"."value_in_usd") AS "cash_flow"
           FROM "public"."all_transactions"
          WHERE ("all_transactions"."usage" = ANY (ARRAY['sale_ias2'::"text", 'revenue_ifrs15'::"text"]))
          GROUP BY "all_transactions"."user_id"
        UNION ALL
         SELECT "all_transactions"."user_id",
            'Outflow for Inventory (IAS 2)'::"text" AS "text",
            "sum"((- "all_transactions"."value_in_usd")) AS "sum"
           FROM "public"."all_transactions"
          WHERE ("all_transactions"."usage" = 'trading_acquisition_ias2'::"text")
          GROUP BY "all_transactions"."user_id"
        UNION ALL
         SELECT "all_transactions"."user_id",
            'Outflow for Gas Fees'::"text" AS "text",
            "sum"((- "all_transactions"."value_in_usd")) AS "sum"
           FROM "public"."all_transactions"
          WHERE ("all_transactions"."usage" = 'gas_fees'::"text")
          GROUP BY "all_transactions"."user_id"
        UNION ALL
         SELECT "all_transactions"."user_id",
            'Outflow for Intangible Assets'::"text" AS "text",
            "sum"((- "all_transactions"."value_in_usd")) AS "sum"
           FROM "public"."all_transactions"
          WHERE ("all_transactions"."usage" = 'investment_acquisition_ias38'::"text")
          GROUP BY "all_transactions"."user_id"
        UNION ALL
         SELECT "all_transactions"."user_id",
            'Inflow from Sale of Intangibles'::"text" AS "text",
            "sum"("all_transactions"."value_in_usd") AS "sum"
           FROM "public"."all_transactions"
          WHERE ("all_transactions"."usage" = 'sale_ias38'::"text")
          GROUP BY "all_transactions"."user_id"
        )
 SELECT "user_id",
    "item",
    "sum"("cash_flow") AS "amount"
   FROM "cash_flows"
  WHERE (("user_id" IS NOT NULL) AND ("cash_flow" IS NOT NULL))
  GROUP BY "user_id", "item"
  ORDER BY "user_id",
        CASE "item"
            WHEN 'Inflow from Sales (IAS 2 & IFRS 15)'::"text" THEN 1
            WHEN 'Outflow for Inventory (IAS 2)'::"text" THEN 2
            WHEN 'Outflow for Gas Fees'::"text" THEN 3
            WHEN 'Outflow for Intangible Assets'::"text" THEN 4
            WHEN 'Inflow from Sale of Intangibles'::"text" THEN 5
            ELSE 99
        END;


ALTER VIEW "public"."v_cash_flow_statement" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_holdings" AS
 WITH "acquisitions" AS (
         SELECT "v_all_transactions_classified"."user_id",
            "v_all_transactions_classified"."asset",
            "sum"("v_all_transactions_classified"."value_in_usd") AS "total_cost_basis",
            "sum"("v_all_transactions_classified"."amount") AS "total_amount_acquired"
           FROM "public"."v_all_transactions_classified"
          WHERE (("v_all_transactions_classified"."transaction_type" = 'BUY'::"text") AND (("v_all_transactions_classified"."usage" <> 'internal_transfer'::"text") OR ("v_all_transactions_classified"."usage" IS NULL)))
          GROUP BY "v_all_transactions_classified"."user_id", "v_all_transactions_classified"."asset"
        ), "current_quantities" AS (
         SELECT "v_all_transactions_classified"."user_id",
            "v_all_transactions_classified"."asset",
            "sum"(
                CASE
                    WHEN ("v_all_transactions_classified"."transaction_type" = ANY (ARRAY['BUY'::"text", 'DEPOSIT'::"text"])) THEN "v_all_transactions_classified"."amount"
                    WHEN ("v_all_transactions_classified"."transaction_type" = ANY (ARRAY['SELL'::"text", 'WITHDRAWAL'::"text"])) THEN (- "v_all_transactions_classified"."amount")
                    ELSE (0)::numeric
                END) AS "current_amount"
           FROM "public"."v_all_transactions_classified"
          WHERE (("v_all_transactions_classified"."usage" <> 'internal_transfer'::"text") OR ("v_all_transactions_classified"."usage" IS NULL))
          GROUP BY "v_all_transactions_classified"."user_id", "v_all_transactions_classified"."asset"
        )
 SELECT "cq"."user_id",
    "cq"."asset",
    "cq"."current_amount",
    "ap"."current_price",
    ("cq"."current_amount" * "ap"."current_price") AS "current_value",
    COALESCE(("acq"."total_cost_basis" / NULLIF("acq"."total_amount_acquired", (0)::numeric)), (0)::numeric) AS "Avg. Buy Price",
    (("cq"."current_amount" * "ap"."current_price") - ("cq"."current_amount" * COALESCE(("acq"."total_cost_basis" / NULLIF("acq"."total_amount_acquired", (0)::numeric)), (0)::numeric))) AS "Unrealized P&L",
    "now"() AS "last_updated"
   FROM (("current_quantities" "cq"
     JOIN "public"."asset_prices" "ap" ON (("cq"."asset" = "ap"."asset")))
     LEFT JOIN "acquisitions" "acq" ON ((("cq"."user_id" = "acq"."user_id") AND ("cq"."asset" = "acq"."asset"))))
  WHERE ("cq"."current_amount" > 0.000000001);


ALTER VIEW "public"."v_holdings" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."wallet_nonces" (
    "user_id" "uuid" NOT NULL,
    "nonce" "text" NOT NULL,
    "expires_at" timestamp with time zone NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."wallet_nonces" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."wallet_sync_state" (
    "user_id" "uuid" NOT NULL,
    "wallet_address" "text" NOT NULL,
    "chain_id" bigint DEFAULT 1 NOT NULL,
    "last_block" bigint DEFAULT 0 NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."wallet_sync_state" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."wallet_transaction" AS
 SELECT "id",
    "user_id",
    "wallet_address",
    "chain_id",
    "direction",
    "tx_hash",
    "block_number",
    "timestamp",
    "from_address",
    "to_address",
    "value_wei",
    "asset_symbol",
    "raw",
    "created_at",
    "asset_decimals",
    "price_usd",
    "fiat_value_usd",
    "occurred_at"
   FROM "public"."wallet_transactions";


ALTER VIEW "public"."wallet_transaction" OWNER TO "postgres";


CREATE SEQUENCE IF NOT EXISTS "public"."wallet_transactions_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."wallet_transactions_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."wallet_transactions_id_seq" OWNED BY "public"."wallet_transactions"."id";



CREATE OR REPLACE VIEW "public"."wallet_tx_with_flags" AS
 SELECT "id",
    "user_id",
    "wallet_address",
    "chain_id",
    "direction",
    "tx_hash",
    "block_number",
    "timestamp",
    "from_address",
    "to_address",
    "value_wei",
    "asset_symbol",
    "raw",
    "created_at",
    "asset_decimals",
    "price_usd",
    "fiat_value_usd",
    "occurred_at",
    (EXISTS ( SELECT 1
           FROM "public"."internal_transfer_links" "l"
          WHERE (("l"."out_tx_id" = "t"."id") OR ("l"."in_tx_id" = "t"."id")))) AS "is_internal_transfer"
   FROM "public"."wallet_transactions" "t";


ALTER VIEW "public"."wallet_tx_with_flags" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."wallets" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid",
    "address" "text" NOT NULL,
    "verified" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."wallets" OWNER TO "postgres";


ALTER TABLE ONLY "public"."exchange_api_credentials" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."exchange_api_credentials_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."internal_transfer_links" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."internal_transfer_links_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."journal_entries" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."journal_entries_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."journal_lines" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."journal_lines_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."payment_vault_addresses" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."payment_vault_addresses_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."transaction_usage_labels" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."transaction_usage_labels_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."wallet_transactions" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."wallet_transactions_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."asset_prices"
    ADD CONSTRAINT "asset_prices_pkey" PRIMARY KEY ("asset");



ALTER TABLE ONLY "public"."audit_logs"
    ADD CONSTRAINT "audit_logs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."clients"
    ADD CONSTRAINT "clients_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."companies"
    ADD CONSTRAINT "companies_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."crypto_payments"
    ADD CONSTRAINT "crypto_payments_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."customers"
    ADD CONSTRAINT "customers_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."daily_exchange_rates"
    ADD CONSTRAINT "daily_exchange_rates_pkey" PRIMARY KEY ("date", "source_currency", "target_currency");



ALTER TABLE ONLY "public"."exchange_accounts"
    ADD CONSTRAINT "exchange_accounts_connection_id_account_uid_key" UNIQUE ("connection_id", "account_uid");



ALTER TABLE ONLY "public"."exchange_accounts"
    ADD CONSTRAINT "exchange_accounts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."exchange_api_credentials"
    ADD CONSTRAINT "exchange_api_credentials_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."exchange_api_credentials"
    ADD CONSTRAINT "exchange_api_credentials_user_id_exchange_key" UNIQUE ("user_id", "exchange");



ALTER TABLE ONLY "public"."exchange_balances"
    ADD CONSTRAINT "exchange_balances_account_id_asset_at_key" UNIQUE ("account_id", "asset", "at");



ALTER TABLE ONLY "public"."exchange_balances"
    ADD CONSTRAINT "exchange_balances_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."exchange_connections"
    ADD CONSTRAINT "exchange_connections_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."exchange_trade_values"
    ADD CONSTRAINT "exchange_trade_values_pkey" PRIMARY KEY ("exchange_trade_id");



ALTER TABLE ONLY "public"."exchange_trades"
    ADD CONSTRAINT "exchange_trades_exchange_external_id_key" UNIQUE ("exchange", "external_id");



ALTER TABLE ONLY "public"."exchange_trades"
    ADD CONSTRAINT "exchange_trades_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."exchange_trades"
    ADD CONSTRAINT "exchange_trades_user_id_exchange_trade_id_key" UNIQUE ("user_id", "exchange", "trade_id");



ALTER TABLE ONLY "public"."exchange_trades"
    ADD CONSTRAINT "exchange_trades_user_id_trade_id_key" UNIQUE ("user_id", "trade_id");



ALTER TABLE ONLY "public"."exchange_transfers"
    ADD CONSTRAINT "exchange_transfers_account_id_txid_direction_key" UNIQUE ("account_id", "txid", "direction");



ALTER TABLE ONLY "public"."exchange_transfers"
    ADD CONSTRAINT "exchange_transfers_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."internal_transfer_links"
    ADD CONSTRAINT "internal_transfer_links_out_tx_id_in_tx_id_key" UNIQUE ("out_tx_id", "in_tx_id");



ALTER TABLE ONLY "public"."internal_transfer_links"
    ADD CONSTRAINT "internal_transfer_links_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."invoices"
    ADD CONSTRAINT "invoices_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."journal_entries"
    ADD CONSTRAINT "journal_entries_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."journal_lines"
    ADD CONSTRAINT "journal_lines_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."meter_events"
    ADD CONSTRAINT "meter_events_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."payment_links"
    ADD CONSTRAINT "payment_links_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."payment_merchants"
    ADD CONSTRAINT "payment_merchants_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."payment_vault_addresses"
    ADD CONSTRAINT "payment_vault_addresses_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."payment_vault_addresses"
    ADD CONSTRAINT "payment_vault_addresses_user_id_network_asset_key" UNIQUE ("user_id", "network", "asset");



ALTER TABLE ONLY "public"."profiles"
    ADD CONSTRAINT "profiles_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."profiles"
    ADD CONSTRAINT "profiles_user_id_key" UNIQUE ("user_id");



ALTER TABLE ONLY "public"."transaction_purposes"
    ADD CONSTRAINT "transaction_purposes_pkey" PRIMARY KEY ("user_id", "source", "source_id");



ALTER TABLE ONLY "public"."transaction_usage_labels"
    ADD CONSTRAINT "transaction_usage_labels_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."transaction_usage_predictions"
    ADD CONSTRAINT "transaction_usage_predictions_pkey" PRIMARY KEY ("user_id", "tx_id", "model");



ALTER TABLE ONLY "public"."transaction_usages"
    ADD CONSTRAINT "transaction_usages_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."transaction_usages"
    ADD CONSTRAINT "transaction_usages_user_id_source_type_source_id_key" UNIQUE ("user_id", "source_type", "source_id");



ALTER TABLE ONLY "public"."transactions"
    ADD CONSTRAINT "transactions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."transactions"
    ADD CONSTRAINT "transactions_transaction_hash_key" UNIQUE ("transaction_hash");



ALTER TABLE ONLY "public"."transfer_links"
    ADD CONSTRAINT "transfer_links_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."transfer_links"
    ADD CONSTRAINT "transfer_links_wallet_tx_id_exchange_transfer_id_key" UNIQUE ("wallet_tx_id", "exchange_transfer_id");



ALTER TABLE ONLY "public"."transfers"
    ADD CONSTRAINT "transfers_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."exchange_connections"
    ADD CONSTRAINT "unique_user_connection_name" UNIQUE ("user_id", "connection_name");



ALTER TABLE ONLY "public"."usage_categories"
    ADD CONSTRAINT "usage_categories_pkey" PRIMARY KEY ("key");



ALTER TABLE ONLY "public"."user_monthly_counters"
    ADD CONSTRAINT "user_monthly_counters_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."user_monthly_counters"
    ADD CONSTRAINT "user_monthly_counters_user_id_month_year_key" UNIQUE ("user_id", "month_year");



ALTER TABLE ONLY "public"."user_sessions"
    ADD CONSTRAINT "user_sessions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."wallet_connections"
    ADD CONSTRAINT "wallet_connections_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."wallet_connections"
    ADD CONSTRAINT "wallet_connections_user_id_wallet_address_key" UNIQUE ("user_id", "wallet_address");



ALTER TABLE ONLY "public"."wallet_nonces"
    ADD CONSTRAINT "wallet_nonces_pkey" PRIMARY KEY ("user_id");



ALTER TABLE ONLY "public"."wallet_sync_state"
    ADD CONSTRAINT "wallet_sync_state_pkey" PRIMARY KEY ("user_id");



ALTER TABLE ONLY "public"."wallet_transactions"
    ADD CONSTRAINT "wallet_transactions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."wallet_transactions"
    ADD CONSTRAINT "wallet_transactions_tx_hash_key" UNIQUE ("tx_hash");



ALTER TABLE ONLY "public"."wallets"
    ADD CONSTRAINT "wallets_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."wallets"
    ADD CONSTRAINT "wallets_user_address_unique" UNIQUE ("user_id", "address");



CREATE INDEX "clients_user_idx" ON "public"."clients" USING "btree" ("user_id");



CREATE INDEX "companies_user_idx" ON "public"."companies" USING "btree" ("user_id");



CREATE INDEX "customers_user_id_idx" ON "public"."customers" USING "btree" ("user_id");



CREATE INDEX "exchange_api_credentials_exchange_idx" ON "public"."exchange_api_credentials" USING "btree" ("exchange");



CREATE INDEX "exchange_api_credentials_user_idx" ON "public"."exchange_api_credentials" USING "btree" ("user_id");



CREATE INDEX "exchange_connections_exchange_idx" ON "public"."exchange_connections" USING "btree" ("exchange");



CREATE INDEX "exchange_connections_user_id_idx" ON "public"."exchange_connections" USING "btree" ("user_id");



CREATE INDEX "idx_audit_logs_user_id" ON "public"."audit_logs" USING "btree" ("user_id");



CREATE INDEX "idx_clients_user_id" ON "public"."clients" USING "btree" ("user_id");



CREATE INDEX "idx_companies_user_id" ON "public"."companies" USING "btree" ("user_id");



CREATE INDEX "idx_crypto_payments_user_id" ON "public"."crypto_payments" USING "btree" ("user_id");



CREATE INDEX "idx_customers_deleted_at" ON "public"."customers" USING "btree" ("deleted_at");



CREATE INDEX "idx_customers_user_id" ON "public"."customers" USING "btree" ("user_id");



CREATE INDEX "idx_exchange_trades_connection_id" ON "public"."exchange_trades" USING "btree" ("exchange_connection_id");



CREATE INDEX "idx_invoices_user_id" ON "public"."invoices" USING "btree" ("user_id");



CREATE INDEX "idx_jlines_entry" ON "public"."journal_lines" USING "btree" ("entry_id");



CREATE INDEX "idx_meter_events_user_id" ON "public"."meter_events" USING "btree" ("user_id");



CREATE INDEX "idx_transaction_usage_labels_user_ctx" ON "public"."transaction_usage_labels" USING "btree" ("user_id", "ctx_id");



CREATE INDEX "idx_transaction_usage_labels_user_tx" ON "public"."transaction_usage_labels" USING "btree" ("user_id", "tx_id");



CREATE INDEX "idx_transactions_chain" ON "public"."transactions" USING "btree" ("chain_id");



CREATE INDEX "idx_transactions_hash" ON "public"."transactions" USING "btree" ("transaction_hash");



CREATE INDEX "idx_transactions_network" ON "public"."transactions" USING "btree" ("network");



CREATE UNIQUE INDEX "idx_transactions_unique" ON "public"."transactions" USING "btree" ("chain_id", "transaction_hash", "log_index");



CREATE INDEX "idx_transactions_user_id" ON "public"."transactions" USING "btree" ("user_id");



CREATE INDEX "idx_transactions_user_time" ON "public"."transactions" USING "btree" ("user_id", "transaction_date" DESC);



CREATE INDEX "idx_transactions_wallet_address" ON "public"."transactions" USING "btree" ("wallet_address");



CREATE INDEX "idx_transfers_client_id" ON "public"."transfers" USING "btree" ("client_id");



CREATE INDEX "idx_transfers_user_id" ON "public"."transfers" USING "btree" ("user_id");



CREATE INDEX "idx_tx_usage_user_tx" ON "public"."transaction_usage_labels" USING "btree" ("user_id", "tx_id");



CREATE INDEX "idx_user_sessions_user_id" ON "public"."user_sessions" USING "btree" ("user_id");



CREATE INDEX "idx_wallet_connections_address" ON "public"."wallet_connections" USING "btree" ("wallet_address");



CREATE INDEX "idx_wallet_connections_user_id" ON "public"."wallet_connections" USING "btree" ("user_id");



CREATE INDEX "idx_wallet_tx_user_ts" ON "public"."wallet_transactions" USING "btree" ("user_id", "timestamp" DESC);



CREATE INDEX "invoices_client_id_idx" ON "public"."invoices" USING "btree" ("client_id");



CREATE INDEX "invoices_company_id_idx" ON "public"."invoices" USING "btree" ("company_id");



CREATE INDEX "invoices_issue_date_idx" ON "public"."invoices" USING "btree" ("issue_date");



CREATE INDEX "invoices_user_id_idx" ON "public"."invoices" USING "btree" ("user_id");



CREATE INDEX "invoices_user_idx" ON "public"."invoices" USING "btree" ("user_id");



CREATE INDEX "itl_in_idx" ON "public"."internal_transfer_links" USING "btree" ("in_tx_id");



CREATE INDEX "itl_out_idx" ON "public"."internal_transfer_links" USING "btree" ("out_tx_id");



CREATE UNIQUE INDEX "payment_merchants_user_id_key" ON "public"."payment_merchants" USING "btree" ("user_id");



CREATE UNIQUE INDEX "transaction_usage_labels_user_ctx_key" ON "public"."transaction_usage_labels" USING "btree" ("user_id", "ctx_id") WHERE ("ctx_id" IS NOT NULL);



CREATE UNIQUE INDEX "transaction_usage_labels_user_tx_key" ON "public"."transaction_usage_labels" USING "btree" ("user_id", "tx_id") WHERE ("tx_id" IS NOT NULL);



CREATE UNIQUE INDEX "wallet_tx_user_hash_uidx" ON "public"."wallet_transactions" USING "btree" ("user_id", "tx_hash");



CREATE UNIQUE INDEX "wallets_user_addr_uniq" ON "public"."wallets" USING "btree" ("user_id", "lower"("address"));



CREATE OR REPLACE TRIGGER "clear_profile_fields_trigger" BEFORE INSERT OR UPDATE ON "public"."profiles" FOR EACH ROW EXECUTE FUNCTION "public"."clear_unused_profile_fields"();



CREATE OR REPLACE TRIGGER "profiles_mirror_id_user_id" BEFORE INSERT OR UPDATE ON "public"."profiles" FOR EACH ROW EXECUTE FUNCTION "public"."fn_profiles_mirror_id_user_id"();



CREATE OR REPLACE TRIGGER "tr_invoices_set_updated_at" BEFORE UPDATE ON "public"."invoices" FOR EACH ROW EXECUTE FUNCTION "public"."tg_invoices_set_updated_at"();



CREATE OR REPLACE TRIGGER "trg_profiles_align_ids" BEFORE INSERT ON "public"."profiles" FOR EACH ROW EXECUTE FUNCTION "public"."profiles_align_ids"();



CREATE OR REPLACE TRIGGER "update_crypto_payments_updated_at" BEFORE UPDATE ON "public"."crypto_payments" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_customers_updated_at" BEFORE UPDATE ON "public"."customers" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_invoices_updated_at" BEFORE UPDATE ON "public"."invoices" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_profiles_updated_at" BEFORE UPDATE ON "public"."profiles" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_transactions_updated_at" BEFORE UPDATE ON "public"."transactions" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_user_monthly_counters_updated_at" BEFORE UPDATE ON "public"."user_monthly_counters" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_wallet_connections_updated_at" BEFORE UPDATE ON "public"."wallet_connections" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



ALTER TABLE ONLY "public"."clients"
    ADD CONSTRAINT "clients_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."companies"
    ADD CONSTRAINT "companies_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."crypto_payments"
    ADD CONSTRAINT "crypto_payments_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."exchange_accounts"
    ADD CONSTRAINT "exchange_accounts_connection_id_fkey" FOREIGN KEY ("connection_id") REFERENCES "public"."exchange_connections"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."exchange_api_credentials"
    ADD CONSTRAINT "exchange_api_credentials_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."exchange_balances"
    ADD CONSTRAINT "exchange_balances_account_id_fkey" FOREIGN KEY ("account_id") REFERENCES "public"."exchange_accounts"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."exchange_connections"
    ADD CONSTRAINT "exchange_connections_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."exchange_trades"
    ADD CONSTRAINT "exchange_trades_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."exchange_transfers"
    ADD CONSTRAINT "exchange_transfers_account_id_fkey" FOREIGN KEY ("account_id") REFERENCES "public"."exchange_accounts"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."exchange_trades"
    ADD CONSTRAINT "fk_exchange_connections" FOREIGN KEY ("exchange_connection_id") REFERENCES "public"."exchange_connections"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."invoices"
    ADD CONSTRAINT "invoices_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."invoices"
    ADD CONSTRAINT "invoices_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."journal_entries"
    ADD CONSTRAINT "journal_entries_tx_id_fkey" FOREIGN KEY ("tx_id") REFERENCES "public"."wallet_transactions"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."journal_entries"
    ADD CONSTRAINT "journal_entries_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."journal_lines"
    ADD CONSTRAINT "journal_lines_entry_id_fkey" FOREIGN KEY ("entry_id") REFERENCES "public"."journal_entries"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."payment_links"
    ADD CONSTRAINT "payment_links_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."payment_merchants"
    ADD CONSTRAINT "payment_merchants_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."payment_vault_addresses"
    ADD CONSTRAINT "payment_vault_addresses_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."profiles"
    ADD CONSTRAINT "profiles_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."transaction_usage_predictions"
    ADD CONSTRAINT "transaction_usage_predictions_tx_id_fkey" FOREIGN KEY ("tx_id") REFERENCES "public"."wallet_transactions"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."transaction_usages"
    ADD CONSTRAINT "transaction_usages_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."transactions"
    ADD CONSTRAINT "transactions_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."transfers"
    ADD CONSTRAINT "transfers_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id");



ALTER TABLE ONLY "public"."transfers"
    ADD CONSTRAINT "transfers_invoice_id_fkey" FOREIGN KEY ("invoice_id") REFERENCES "public"."invoices"("id");



ALTER TABLE ONLY "public"."transfers"
    ADD CONSTRAINT "transfers_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."wallet_connections"
    ADD CONSTRAINT "wallet_connections_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."wallets"
    ADD CONSTRAINT "wallets_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."profiles"("user_id") ON DELETE CASCADE;



CREATE POLICY "Insert own profile" ON "public"."profiles" FOR INSERT WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "Update own profile" ON "public"."profiles" FOR UPDATE USING (("auth"."uid"() = "user_id")) WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "allow_authenticated_select_profiles" ON "public"."profiles" FOR SELECT TO "authenticated" USING (("user_id" = "auth"."uid"()));



CREATE POLICY "allow_update_own_profile" ON "public"."profiles" FOR UPDATE TO "authenticated" USING (("user_id" = "auth"."uid"())) WITH CHECK (("user_id" = "auth"."uid"()));



CREATE POLICY "allow_upsert_own_profile" ON "public"."profiles" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = "auth"."uid"()));



CREATE POLICY "allow_user_manage_clients" ON "public"."clients" TO "authenticated" USING (("auth"."uid"() = "user_id")) WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "allow_user_manage_companies" ON "public"."companies" TO "authenticated" USING (("auth"."uid"() = "user_id")) WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "allow_user_manage_exchange_trade_values" ON "public"."exchange_trade_values" TO "authenticated" USING (("auth"."uid"() = "user_id")) WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "allow_user_manage_transfers" ON "public"."transfers" TO "authenticated" USING (("auth"."uid"() = "user_id")) WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "allow_user_modify_customers" ON "public"."customers" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = "auth"."uid"()));



CREATE POLICY "allow_user_modify_invoices" ON "public"."invoices" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = "auth"."uid"()));



CREATE POLICY "allow_user_modify_wallets" ON "public"."wallet_connections" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = "auth"."uid"()));



CREATE POLICY "allow_user_select_crypto_payments" ON "public"."crypto_payments" FOR SELECT TO "authenticated" USING (("user_id" = "auth"."uid"()));



CREATE POLICY "allow_user_select_customers" ON "public"."customers" FOR SELECT TO "authenticated" USING (("user_id" = "auth"."uid"()));



CREATE POLICY "allow_user_select_invoices" ON "public"."invoices" FOR SELECT TO "authenticated" USING (("user_id" = "auth"."uid"()));



CREATE POLICY "allow_user_select_own_exchange_connections" ON "public"."exchange_connections" FOR SELECT TO "authenticated" USING (("user_id" = "auth"."uid"()));



CREATE POLICY "allow_user_select_own_exchange_trades" ON "public"."exchange_trades" FOR SELECT TO "authenticated" USING (("user_id" = "auth"."uid"()));



CREATE POLICY "allow_user_select_own_wallet_connections" ON "public"."wallet_connections" FOR SELECT TO "authenticated" USING (("user_id" = "auth"."uid"()));



CREATE POLICY "allow_user_select_own_wallet_transactions" ON "public"."wallet_transactions" FOR SELECT TO "authenticated" USING (("user_id" = "auth"."uid"()));



CREATE POLICY "allow_user_select_transactions" ON "public"."transactions" FOR SELECT TO "authenticated" USING (("user_id" = "auth"."uid"()));



CREATE POLICY "allow_user_select_wallets" ON "public"."wallet_connections" FOR SELECT TO "authenticated" USING (("user_id" = "auth"."uid"()));



CREATE POLICY "allow_user_update_customers" ON "public"."customers" FOR UPDATE TO "authenticated" USING (("user_id" = "auth"."uid"())) WITH CHECK (("user_id" = "auth"."uid"()));



CREATE POLICY "allow_user_update_invoices" ON "public"."invoices" FOR UPDATE TO "authenticated" USING (("user_id" = "auth"."uid"())) WITH CHECK (("user_id" = "auth"."uid"()));



CREATE POLICY "allow_user_update_own_exchange_trades" ON "public"."exchange_trades" FOR UPDATE TO "authenticated" USING (("user_id" = "auth"."uid"())) WITH CHECK (("user_id" = "auth"."uid"()));



CREATE POLICY "allow_user_update_own_wallet_transactions" ON "public"."wallet_transactions" FOR UPDATE TO "authenticated" USING (("user_id" = "auth"."uid"())) WITH CHECK (("user_id" = "auth"."uid"()));



CREATE POLICY "allow_user_update_wallets" ON "public"."wallet_connections" FOR UPDATE TO "authenticated" USING (("user_id" = "auth"."uid"())) WITH CHECK (("user_id" = "auth"."uid"()));



ALTER TABLE "public"."audit_logs" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "auth_delete_wallets" ON "public"."wallet_connections" FOR DELETE TO "authenticated" USING (("user_id" = "auth"."uid"()));



CREATE POLICY "auth_insert_customers" ON "public"."customers" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = "auth"."uid"()));



CREATE POLICY "auth_insert_invoices" ON "public"."invoices" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = "auth"."uid"()));



CREATE POLICY "auth_insert_profiles" ON "public"."profiles" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = "auth"."uid"()));



CREATE POLICY "auth_insert_wallet_tx" ON "public"."wallet_transactions" FOR INSERT TO "authenticated" WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "auth_insert_wallets" ON "public"."wallet_connections" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = "auth"."uid"()));



CREATE POLICY "auth_select_audit_logs" ON "public"."audit_logs" FOR SELECT TO "authenticated" USING (("user_id" = "auth"."uid"()));



CREATE POLICY "auth_select_crypto_payments" ON "public"."crypto_payments" FOR SELECT TO "authenticated" USING (("user_id" = "auth"."uid"()));



CREATE POLICY "auth_select_customers" ON "public"."customers" FOR SELECT TO "authenticated" USING (("user_id" = "auth"."uid"()));



CREATE POLICY "auth_select_invoices" ON "public"."invoices" FOR SELECT TO "authenticated" USING (("user_id" = "auth"."uid"()));



CREATE POLICY "auth_select_meter_events" ON "public"."meter_events" FOR SELECT TO "authenticated" USING (("user_id" = "auth"."uid"()));



CREATE POLICY "auth_select_profiles" ON "public"."profiles" FOR SELECT TO "authenticated" USING (("user_id" = "auth"."uid"()));



CREATE POLICY "auth_select_transactions" ON "public"."transactions" FOR SELECT TO "authenticated" USING (("user_id" = "auth"."uid"()));



CREATE POLICY "auth_select_user_monthly_counters" ON "public"."user_monthly_counters" FOR SELECT TO "authenticated" USING (("user_id" = "auth"."uid"()));



CREATE POLICY "auth_select_user_sessions" ON "public"."user_sessions" FOR SELECT TO "authenticated" USING (("user_id" = "auth"."uid"()));



CREATE POLICY "auth_select_wallet_nonces" ON "public"."wallet_nonces" FOR SELECT TO "authenticated" USING (("auth"."uid"() = "user_id"));



CREATE POLICY "auth_select_wallet_sync" ON "public"."wallet_sync_state" FOR SELECT TO "authenticated" USING (("auth"."uid"() = "user_id"));



CREATE POLICY "auth_select_wallet_tx" ON "public"."wallet_transactions" FOR SELECT TO "authenticated" USING (("auth"."uid"() = "user_id"));



CREATE POLICY "auth_select_wallets" ON "public"."wallet_connections" FOR SELECT TO "authenticated" USING (("user_id" = "auth"."uid"()));



CREATE POLICY "auth_select_wallets" ON "public"."wallets" FOR SELECT TO "authenticated" USING (("auth"."uid"() = "user_id"));



CREATE POLICY "auth_update_customers" ON "public"."customers" FOR UPDATE TO "authenticated" USING (("user_id" = "auth"."uid"())) WITH CHECK (("user_id" = "auth"."uid"()));



CREATE POLICY "auth_update_invoices" ON "public"."invoices" FOR UPDATE TO "authenticated" USING (("user_id" = "auth"."uid"())) WITH CHECK (("user_id" = "auth"."uid"()));



CREATE POLICY "auth_update_profiles" ON "public"."profiles" FOR UPDATE TO "authenticated" USING (("user_id" = "auth"."uid"())) WITH CHECK (("user_id" = "auth"."uid"()));



CREATE POLICY "auth_update_wallets" ON "public"."wallet_connections" FOR UPDATE TO "authenticated" USING (("user_id" = "auth"."uid"())) WITH CHECK (("user_id" = "auth"."uid"()));



CREATE POLICY "auth_upsert_wallet_nonces" ON "public"."wallet_nonces" TO "authenticated" USING (("auth"."uid"() = "user_id")) WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "auth_upsert_wallet_sync" ON "public"."wallet_sync_state" TO "authenticated" USING (("auth"."uid"() = "user_id")) WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "auth_upsert_wallets" ON "public"."wallets" TO "authenticated" USING (("auth"."uid"() = "user_id")) WITH CHECK (("auth"."uid"() = "user_id"));



ALTER TABLE "public"."clients" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "clients_ins_own" ON "public"."clients" FOR INSERT WITH CHECK (("user_id" = "auth"."uid"()));



CREATE POLICY "clients_select_own" ON "public"."clients" FOR SELECT USING (("user_id" = "auth"."uid"()));



CREATE POLICY "clients_upd_own" ON "public"."clients" FOR UPDATE USING (("user_id" = "auth"."uid"())) WITH CHECK (("user_id" = "auth"."uid"()));



ALTER TABLE "public"."companies" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "companies_ins_own" ON "public"."companies" FOR INSERT WITH CHECK (("user_id" = "auth"."uid"()));



CREATE POLICY "companies_select_own" ON "public"."companies" FOR SELECT USING (("user_id" = "auth"."uid"()));



CREATE POLICY "companies_upd_own" ON "public"."companies" FOR UPDATE USING (("user_id" = "auth"."uid"())) WITH CHECK (("user_id" = "auth"."uid"()));



CREATE POLICY "cred_delete_own" ON "public"."exchange_api_credentials" FOR DELETE USING (("auth"."uid"() = "user_id"));



CREATE POLICY "cred_select_own" ON "public"."exchange_api_credentials" FOR SELECT USING (("auth"."uid"() = "user_id"));



CREATE POLICY "cred_upsert_own" ON "public"."exchange_api_credentials" FOR INSERT WITH CHECK (("auth"."uid"() = "user_id"));



ALTER TABLE "public"."crypto_payments" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."customers" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "customers_ins_own" ON "public"."customers" FOR INSERT WITH CHECK (("user_id" = "auth"."uid"()));



CREATE POLICY "customers_select_own" ON "public"."customers" FOR SELECT USING (("user_id" = "auth"."uid"()));



CREATE POLICY "customers_upd_own" ON "public"."customers" FOR UPDATE USING (("user_id" = "auth"."uid"())) WITH CHECK (("user_id" = "auth"."uid"()));



ALTER TABLE "public"."exchange_api_credentials" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."exchange_connections" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "exchange_connections owner rw" ON "public"."exchange_connections" USING (("auth"."uid"() = "user_id")) WITH CHECK (("auth"."uid"() = "user_id"));



ALTER TABLE "public"."exchange_trade_values" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."exchange_trades" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."invoices" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "invoices_delete_own" ON "public"."invoices" FOR DELETE USING (("user_id" = "auth"."uid"()));



CREATE POLICY "invoices_ins_own" ON "public"."invoices" FOR INSERT WITH CHECK (("user_id" = "auth"."uid"()));



CREATE POLICY "invoices_insert_own" ON "public"."invoices" FOR INSERT WITH CHECK (("user_id" = "auth"."uid"()));



CREATE POLICY "invoices_select_own" ON "public"."invoices" FOR SELECT USING (("user_id" = "auth"."uid"()));



CREATE POLICY "invoices_upd_own" ON "public"."invoices" FOR UPDATE USING (("user_id" = "auth"."uid"())) WITH CHECK (("user_id" = "auth"."uid"()));



CREATE POLICY "invoices_update_own" ON "public"."invoices" FOR UPDATE USING (("user_id" = "auth"."uid"()));



CREATE POLICY "je_delete_own" ON "public"."journal_entries" FOR DELETE USING (("auth"."uid"() = "user_id"));



CREATE POLICY "je_ins_owner" ON "public"."journal_entries" FOR INSERT WITH CHECK (("user_id" = "auth"."uid"()));



CREATE POLICY "je_insert_own" ON "public"."journal_entries" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = "auth"."uid"()));



CREATE POLICY "je_select_own" ON "public"."journal_entries" FOR SELECT TO "authenticated" USING (("user_id" = "auth"."uid"()));



CREATE POLICY "je_select_owner" ON "public"."journal_entries" FOR SELECT USING (("user_id" = "auth"."uid"()));



CREATE POLICY "je_self_all" ON "public"."journal_entries" USING (("auth"."uid"() = "user_id")) WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "je_upd_owner" ON "public"."journal_entries" FOR UPDATE USING (("user_id" = "auth"."uid"())) WITH CHECK (("user_id" = "auth"."uid"()));



CREATE POLICY "je_update_own" ON "public"."journal_entries" FOR UPDATE USING (("auth"."uid"() = "user_id")) WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "jl_ins_owner" ON "public"."journal_lines" FOR INSERT WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."journal_entries" "je"
  WHERE (("je"."id" = "journal_lines"."entry_id") AND ("je"."user_id" = "auth"."uid"())))));



CREATE POLICY "jl_select_owner" ON "public"."journal_lines" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "public"."journal_entries" "je"
  WHERE (("je"."id" = "journal_lines"."entry_id") AND ("je"."user_id" = "auth"."uid"())))));



CREATE POLICY "jl_upd_owner" ON "public"."journal_lines" FOR UPDATE USING ((EXISTS ( SELECT 1
   FROM "public"."journal_entries" "je"
  WHERE (("je"."id" = "journal_lines"."entry_id") AND ("je"."user_id" = "auth"."uid"()))))) WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."journal_entries" "je"
  WHERE (("je"."id" = "journal_lines"."entry_id") AND ("je"."user_id" = "auth"."uid"())))));



ALTER TABLE "public"."journal_entries" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."journal_lines" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "labels_delete_own" ON "public"."transaction_usage_labels" FOR DELETE USING (("auth"."uid"() = "user_id"));



CREATE POLICY "labels_select_own" ON "public"."transaction_usage_labels" FOR SELECT USING (("auth"."uid"() = "user_id"));



CREATE POLICY "labels_update_own" ON "public"."transaction_usage_labels" FOR UPDATE USING (("auth"."uid"() = "user_id")) WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "labels_upsert_own" ON "public"."transaction_usage_labels" FOR INSERT WITH CHECK (("auth"."uid"() = "user_id"));



ALTER TABLE "public"."meter_events" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."payment_links" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."payment_merchants" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."payment_vault_addresses" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "pl_ins_own" ON "public"."payment_links" FOR INSERT WITH CHECK (("user_id" = "auth"."uid"()));



CREATE POLICY "pl_select_own" ON "public"."payment_links" FOR SELECT USING (("user_id" = "auth"."uid"()));



CREATE POLICY "pm_select_own" ON "public"."payment_merchants" FOR SELECT USING (("user_id" = "auth"."uid"()));



CREATE POLICY "pm_upsert_own" ON "public"."payment_merchants" USING (("user_id" = "auth"."uid"())) WITH CHECK (("user_id" = "auth"."uid"()));



CREATE POLICY "pred_select_own" ON "public"."transaction_usage_predictions" FOR SELECT USING (("auth"."uid"() = "user_id"));



CREATE POLICY "pred_update_own" ON "public"."transaction_usage_predictions" FOR UPDATE USING (("auth"."uid"() = "user_id")) WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "pred_upsert_own" ON "public"."transaction_usage_predictions" FOR INSERT WITH CHECK (("auth"."uid"() = "user_id"));



ALTER TABLE "public"."profiles" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "profiles_insert_self_only" ON "public"."profiles" FOR INSERT WITH CHECK (("user_id" = "auth"."uid"()));



CREATE POLICY "profiles_select_own" ON "public"."profiles" FOR SELECT USING (("id" = "auth"."uid"()));



CREATE POLICY "profiles_select_owner_only" ON "public"."profiles" FOR SELECT USING (("user_id" = "auth"."uid"()));



CREATE POLICY "profiles_update_owner_only" ON "public"."profiles" FOR UPDATE USING (("user_id" = "auth"."uid"())) WITH CHECK (("user_id" = "auth"."uid"()));



CREATE POLICY "profiles_upsert_own" ON "public"."profiles" USING (("id" = "auth"."uid"())) WITH CHECK (("id" = "auth"."uid"()));



CREATE POLICY "tp_select_own" ON "public"."transaction_purposes" FOR SELECT USING (("user_id" = "auth"."uid"()));



CREATE POLICY "tp_upsert_own" ON "public"."transaction_purposes" USING (("user_id" = "auth"."uid"())) WITH CHECK (("user_id" = "auth"."uid"()));



ALTER TABLE "public"."transaction_purposes" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."transaction_usage_labels" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."transaction_usage_predictions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."transactions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."transfers" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "tx_delete_self" ON "public"."wallet_transactions" FOR DELETE USING (("auth"."uid"() = "user_id"));



CREATE POLICY "tx_insert_self" ON "public"."wallet_transactions" FOR INSERT WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "tx_select_self" ON "public"."wallet_transactions" FOR SELECT USING (("auth"."uid"() = "user_id"));



CREATE POLICY "tx_update_self" ON "public"."wallet_transactions" FOR UPDATE USING (("auth"."uid"() = "user_id")) WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "tx_usage_ins_owner" ON "public"."transaction_usage_labels" FOR INSERT WITH CHECK (("user_id" = "auth"."uid"()));



CREATE POLICY "tx_usage_select_owner" ON "public"."transaction_usage_labels" FOR SELECT USING (("user_id" = "auth"."uid"()));



CREATE POLICY "tx_usage_upd_owner" ON "public"."transaction_usage_labels" FOR UPDATE USING (("user_id" = "auth"."uid"())) WITH CHECK (("user_id" = "auth"."uid"()));



ALTER TABLE "public"."user_monthly_counters" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."user_sessions" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "vault_ins_own" ON "public"."payment_vault_addresses" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = "auth"."uid"()));



CREATE POLICY "vault_select_own" ON "public"."payment_vault_addresses" FOR SELECT TO "authenticated" USING (("user_id" = "auth"."uid"()));



CREATE POLICY "vault_upd_own" ON "public"."payment_vault_addresses" FOR UPDATE TO "authenticated" USING (("user_id" = "auth"."uid"()));



CREATE POLICY "vce_delete_own" ON "public"."exchange_connections" FOR DELETE USING (("auth"."uid"() = "user_id"));



CREATE POLICY "vce_insert_own" ON "public"."exchange_connections" FOR INSERT WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "vce_select_own" ON "public"."exchange_connections" FOR SELECT USING (("auth"."uid"() = "user_id"));



CREATE POLICY "vce_update_own" ON "public"."exchange_connections" FOR UPDATE USING (("auth"."uid"() = "user_id")) WITH CHECK (("auth"."uid"() = "user_id"));



ALTER TABLE "public"."wallet_connections" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."wallet_nonces" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."wallet_sync_state" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."wallet_transactions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."wallets" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "wallets select own" ON "public"."wallets" FOR SELECT TO "authenticated" USING (("user_id" = "auth"."uid"()));



CREATE POLICY "wallets update own" ON "public"."wallets" FOR UPDATE TO "authenticated" USING (("user_id" = "auth"."uid"())) WITH CHECK (("user_id" = "auth"."uid"()));



CREATE POLICY "wallets upsert own" ON "public"."wallets" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = "auth"."uid"()));



CREATE POLICY "wallets_del_own" ON "public"."wallets" FOR DELETE USING (("user_id" = "auth"."uid"()));



CREATE POLICY "wallets_delete_own" ON "public"."wallets" FOR DELETE TO "authenticated" USING (("user_id" = "auth"."uid"()));



CREATE POLICY "wallets_delete_self" ON "public"."wallets" FOR DELETE USING (("auth"."uid"() = "user_id"));



CREATE POLICY "wallets_ins" ON "public"."wallets" FOR INSERT WITH CHECK (("user_id" = "auth"."uid"()));



CREATE POLICY "wallets_ins_own" ON "public"."wallets" FOR INSERT WITH CHECK (("user_id" = "auth"."uid"()));



CREATE POLICY "wallets_insert_own" ON "public"."wallets" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = "auth"."uid"()));



CREATE POLICY "wallets_insert_self" ON "public"."wallets" FOR INSERT WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "wallets_sel" ON "public"."wallets" FOR SELECT USING (("user_id" = "auth"."uid"()));



CREATE POLICY "wallets_select_own" ON "public"."wallets" FOR SELECT TO "authenticated" USING (("user_id" = "auth"."uid"()));



CREATE POLICY "wallets_select_self" ON "public"."wallets" FOR SELECT USING (("auth"."uid"() = "user_id"));



CREATE POLICY "wallets_upd" ON "public"."wallets" FOR UPDATE USING (("user_id" = "auth"."uid"()));



CREATE POLICY "wallets_upd_own" ON "public"."wallets" FOR UPDATE USING (("user_id" = "auth"."uid"()));



CREATE POLICY "wallets_update_own" ON "public"."wallets" FOR UPDATE TO "authenticated" USING (("user_id" = "auth"."uid"()));



CREATE POLICY "wallets_update_self" ON "public"."wallets" FOR UPDATE USING (("auth"."uid"() = "user_id")) WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "wt_insert_own" ON "public"."wallet_transactions" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = "auth"."uid"()));



CREATE POLICY "wt_select_own" ON "public"."wallet_transactions" FOR SELECT TO "authenticated" USING (("user_id" = "auth"."uid"()));



CREATE POLICY "wtx_delete_own" ON "public"."wallet_transactions" FOR DELETE USING (("auth"."uid"() = "user_id"));



CREATE POLICY "wtx_insert_own" ON "public"."wallet_transactions" FOR INSERT WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "wtx_select_own" ON "public"."wallet_transactions" FOR SELECT USING (("auth"."uid"() = "user_id"));



CREATE POLICY "wtx_update_own" ON "public"."wallet_transactions" FOR UPDATE USING (("auth"."uid"() = "user_id")) WITH CHECK (("auth"."uid"() = "user_id"));





ALTER PUBLICATION "supabase_realtime" OWNER TO "postgres";


GRANT USAGE ON SCHEMA "public" TO "postgres";
GRANT USAGE ON SCHEMA "public" TO "anon";
GRANT USAGE ON SCHEMA "public" TO "authenticated";
GRANT USAGE ON SCHEMA "public" TO "service_role";

























































































































































GRANT ALL ON FUNCTION "public"."clear_unused_profile_fields"() TO "anon";
GRANT ALL ON FUNCTION "public"."clear_unused_profile_fields"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."clear_unused_profile_fields"() TO "service_role";



GRANT ALL ON FUNCTION "public"."decrypt_secret"("enc_input" "bytea", "key_input" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."decrypt_secret"("enc_input" "bytea", "key_input" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."decrypt_secret"("enc_input" "bytea", "key_input" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."encrypt_secret"("plain_input" "text", "key_input" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."encrypt_secret"("plain_input" "text", "key_input" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."encrypt_secret"("plain_input" "text", "key_input" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."fn_profiles_mirror_id_user_id"() TO "anon";
GRANT ALL ON FUNCTION "public"."fn_profiles_mirror_id_user_id"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."fn_profiles_mirror_id_user_id"() TO "service_role";



GRANT ALL ON FUNCTION "public"."get_decrypted_connection"("p_user_id" "uuid", "p_exchange" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."get_decrypted_connection"("p_user_id" "uuid", "p_exchange" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_decrypted_connection"("p_user_id" "uuid", "p_exchange" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."handle_new_user"() TO "anon";
GRANT ALL ON FUNCTION "public"."handle_new_user"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."handle_new_user"() TO "service_role";



GRANT ALL ON FUNCTION "public"."profiles_align_ids"() TO "anon";
GRANT ALL ON FUNCTION "public"."profiles_align_ids"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."profiles_align_ids"() TO "service_role";



GRANT ALL ON FUNCTION "public"."tg_invoices_set_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."tg_invoices_set_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."tg_invoices_set_updated_at"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_updated_at_column"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_updated_at_column"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_updated_at_column"() TO "service_role";


















GRANT ALL ON TABLE "public"."asset_prices" TO "anon";
GRANT ALL ON TABLE "public"."asset_prices" TO "authenticated";
GRANT ALL ON TABLE "public"."asset_prices" TO "service_role";



GRANT ALL ON TABLE "public"."daily_exchange_rates" TO "anon";
GRANT ALL ON TABLE "public"."daily_exchange_rates" TO "authenticated";
GRANT ALL ON TABLE "public"."daily_exchange_rates" TO "service_role";



GRANT ALL ON TABLE "public"."exchange_trades" TO "anon";
GRANT ALL ON TABLE "public"."exchange_trades" TO "authenticated";
GRANT ALL ON TABLE "public"."exchange_trades" TO "service_role";



GRANT ALL ON TABLE "public"."wallet_transactions" TO "anon";
GRANT ALL ON TABLE "public"."wallet_transactions" TO "authenticated";
GRANT ALL ON TABLE "public"."wallet_transactions" TO "service_role";



GRANT ALL ON TABLE "public"."all_transactions" TO "anon";
GRANT ALL ON TABLE "public"."all_transactions" TO "authenticated";
GRANT ALL ON TABLE "public"."all_transactions" TO "service_role";



GRANT ALL ON TABLE "public"."audit_logs" TO "anon";
GRANT ALL ON TABLE "public"."audit_logs" TO "authenticated";
GRANT ALL ON TABLE "public"."audit_logs" TO "service_role";



GRANT ALL ON TABLE "public"."clients" TO "anon";
GRANT ALL ON TABLE "public"."clients" TO "authenticated";
GRANT ALL ON TABLE "public"."clients" TO "service_role";



GRANT ALL ON TABLE "public"."companies" TO "anon";
GRANT ALL ON TABLE "public"."companies" TO "authenticated";
GRANT ALL ON TABLE "public"."companies" TO "service_role";



GRANT ALL ON TABLE "public"."crypto_payments" TO "anon";
GRANT ALL ON TABLE "public"."crypto_payments" TO "authenticated";
GRANT ALL ON TABLE "public"."crypto_payments" TO "service_role";



GRANT ALL ON TABLE "public"."customers" TO "anon";
GRANT ALL ON TABLE "public"."customers" TO "authenticated";
GRANT ALL ON TABLE "public"."customers" TO "service_role";



GRANT ALL ON TABLE "public"."exchange_accounts" TO "anon";
GRANT ALL ON TABLE "public"."exchange_accounts" TO "authenticated";
GRANT ALL ON TABLE "public"."exchange_accounts" TO "service_role";



GRANT ALL ON SEQUENCE "public"."exchange_accounts_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."exchange_accounts_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."exchange_accounts_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."exchange_api_credentials" TO "anon";
GRANT ALL ON TABLE "public"."exchange_api_credentials" TO "authenticated";
GRANT ALL ON TABLE "public"."exchange_api_credentials" TO "service_role";



GRANT ALL ON SEQUENCE "public"."exchange_api_credentials_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."exchange_api_credentials_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."exchange_api_credentials_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."exchange_balances" TO "anon";
GRANT ALL ON TABLE "public"."exchange_balances" TO "authenticated";
GRANT ALL ON TABLE "public"."exchange_balances" TO "service_role";



GRANT ALL ON SEQUENCE "public"."exchange_balances_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."exchange_balances_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."exchange_balances_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."exchange_connections" TO "anon";
GRANT ALL ON TABLE "public"."exchange_connections" TO "authenticated";
GRANT ALL ON TABLE "public"."exchange_connections" TO "service_role";



GRANT ALL ON SEQUENCE "public"."exchange_connections_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."exchange_connections_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."exchange_connections_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."exchange_trade_values" TO "anon";
GRANT ALL ON TABLE "public"."exchange_trade_values" TO "authenticated";
GRANT ALL ON TABLE "public"."exchange_trade_values" TO "service_role";



GRANT ALL ON TABLE "public"."exchange_transfers" TO "anon";
GRANT ALL ON TABLE "public"."exchange_transfers" TO "authenticated";
GRANT ALL ON TABLE "public"."exchange_transfers" TO "service_role";



GRANT ALL ON SEQUENCE "public"."exchange_transfers_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."exchange_transfers_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."exchange_transfers_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."wallet_tx_norm" TO "anon";
GRANT ALL ON TABLE "public"."wallet_tx_norm" TO "authenticated";
GRANT ALL ON TABLE "public"."wallet_tx_norm" TO "service_role";



GRANT ALL ON TABLE "public"."internal_transfer_candidates" TO "anon";
GRANT ALL ON TABLE "public"."internal_transfer_candidates" TO "authenticated";
GRANT ALL ON TABLE "public"."internal_transfer_candidates" TO "service_role";



GRANT ALL ON TABLE "public"."internal_transfer_links" TO "anon";
GRANT ALL ON TABLE "public"."internal_transfer_links" TO "authenticated";
GRANT ALL ON TABLE "public"."internal_transfer_links" TO "service_role";



GRANT ALL ON SEQUENCE "public"."internal_transfer_links_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."internal_transfer_links_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."internal_transfer_links_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."v_all_transactions_classified" TO "anon";
GRANT ALL ON TABLE "public"."v_all_transactions_classified" TO "authenticated";
GRANT ALL ON TABLE "public"."v_all_transactions_classified" TO "service_role";



GRANT ALL ON TABLE "public"."internal_transfer_pairs" TO "anon";
GRANT ALL ON TABLE "public"."internal_transfer_pairs" TO "authenticated";
GRANT ALL ON TABLE "public"."internal_transfer_pairs" TO "service_role";



GRANT ALL ON TABLE "public"."invoices" TO "anon";
GRANT ALL ON TABLE "public"."invoices" TO "authenticated";
GRANT ALL ON TABLE "public"."invoices" TO "service_role";



GRANT ALL ON TABLE "public"."journal_entries" TO "anon";
GRANT ALL ON TABLE "public"."journal_entries" TO "authenticated";
GRANT ALL ON TABLE "public"."journal_entries" TO "service_role";



GRANT ALL ON SEQUENCE "public"."journal_entries_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."journal_entries_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."journal_entries_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."journal_lines" TO "anon";
GRANT ALL ON TABLE "public"."journal_lines" TO "authenticated";
GRANT ALL ON TABLE "public"."journal_lines" TO "service_role";



GRANT ALL ON SEQUENCE "public"."journal_lines_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."journal_lines_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."journal_lines_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."meter_events" TO "anon";
GRANT ALL ON TABLE "public"."meter_events" TO "authenticated";
GRANT ALL ON TABLE "public"."meter_events" TO "service_role";



GRANT ALL ON TABLE "public"."payment_links" TO "anon";
GRANT ALL ON TABLE "public"."payment_links" TO "authenticated";
GRANT ALL ON TABLE "public"."payment_links" TO "service_role";



GRANT ALL ON TABLE "public"."payment_merchants" TO "anon";
GRANT ALL ON TABLE "public"."payment_merchants" TO "authenticated";
GRANT ALL ON TABLE "public"."payment_merchants" TO "service_role";



GRANT ALL ON TABLE "public"."payment_vault_addresses" TO "anon";
GRANT ALL ON TABLE "public"."payment_vault_addresses" TO "authenticated";
GRANT ALL ON TABLE "public"."payment_vault_addresses" TO "service_role";



GRANT ALL ON SEQUENCE "public"."payment_vault_addresses_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."payment_vault_addresses_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."payment_vault_addresses_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."profiles" TO "anon";
GRANT ALL ON TABLE "public"."profiles" TO "authenticated";
GRANT ALL ON TABLE "public"."profiles" TO "service_role";



GRANT ALL ON TABLE "public"."transaction_purposes" TO "anon";
GRANT ALL ON TABLE "public"."transaction_purposes" TO "authenticated";
GRANT ALL ON TABLE "public"."transaction_purposes" TO "service_role";



GRANT ALL ON TABLE "public"."transaction_usage_labels" TO "anon";
GRANT ALL ON TABLE "public"."transaction_usage_labels" TO "authenticated";
GRANT ALL ON TABLE "public"."transaction_usage_labels" TO "service_role";



GRANT ALL ON SEQUENCE "public"."transaction_usage_labels_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."transaction_usage_labels_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."transaction_usage_labels_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."transaction_usage_predictions" TO "anon";
GRANT ALL ON TABLE "public"."transaction_usage_predictions" TO "authenticated";
GRANT ALL ON TABLE "public"."transaction_usage_predictions" TO "service_role";



GRANT ALL ON TABLE "public"."transaction_usages" TO "anon";
GRANT ALL ON TABLE "public"."transaction_usages" TO "authenticated";
GRANT ALL ON TABLE "public"."transaction_usages" TO "service_role";



GRANT ALL ON TABLE "public"."transactions" TO "anon";
GRANT ALL ON TABLE "public"."transactions" TO "authenticated";
GRANT ALL ON TABLE "public"."transactions" TO "service_role";



GRANT ALL ON TABLE "public"."transfer_links" TO "anon";
GRANT ALL ON TABLE "public"."transfer_links" TO "authenticated";
GRANT ALL ON TABLE "public"."transfer_links" TO "service_role";



GRANT ALL ON SEQUENCE "public"."transfer_links_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."transfer_links_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."transfer_links_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."transfers" TO "anon";
GRANT ALL ON TABLE "public"."transfers" TO "authenticated";
GRANT ALL ON TABLE "public"."transfers" TO "service_role";



GRANT ALL ON TABLE "public"."usage_categories" TO "anon";
GRANT ALL ON TABLE "public"."usage_categories" TO "authenticated";
GRANT ALL ON TABLE "public"."usage_categories" TO "service_role";



GRANT ALL ON TABLE "public"."user_monthly_counters" TO "anon";
GRANT ALL ON TABLE "public"."user_monthly_counters" TO "authenticated";
GRANT ALL ON TABLE "public"."user_monthly_counters" TO "service_role";



GRANT ALL ON TABLE "public"."user_sessions" TO "anon";
GRANT ALL ON TABLE "public"."user_sessions" TO "authenticated";
GRANT ALL ON TABLE "public"."user_sessions" TO "service_role";



GRANT ALL ON TABLE "public"."wallet_connections" TO "anon";
GRANT ALL ON TABLE "public"."wallet_connections" TO "authenticated";
GRANT ALL ON TABLE "public"."wallet_connections" TO "service_role";



GRANT ALL ON TABLE "public"."v_all_transactions" TO "anon";
GRANT ALL ON TABLE "public"."v_all_transactions" TO "authenticated";
GRANT ALL ON TABLE "public"."v_all_transactions" TO "service_role";



GRANT ALL ON TABLE "public"."v_profit_loss_statement" TO "anon";
GRANT ALL ON TABLE "public"."v_profit_loss_statement" TO "authenticated";
GRANT ALL ON TABLE "public"."v_profit_loss_statement" TO "service_role";



GRANT ALL ON TABLE "public"."v_balance_sheet" TO "anon";
GRANT ALL ON TABLE "public"."v_balance_sheet" TO "authenticated";
GRANT ALL ON TABLE "public"."v_balance_sheet" TO "service_role";



GRANT ALL ON TABLE "public"."v_cash_flow_statement" TO "anon";
GRANT ALL ON TABLE "public"."v_cash_flow_statement" TO "authenticated";
GRANT ALL ON TABLE "public"."v_cash_flow_statement" TO "service_role";



GRANT ALL ON TABLE "public"."v_holdings" TO "anon";
GRANT ALL ON TABLE "public"."v_holdings" TO "authenticated";
GRANT ALL ON TABLE "public"."v_holdings" TO "service_role";



GRANT ALL ON TABLE "public"."wallet_nonces" TO "anon";
GRANT ALL ON TABLE "public"."wallet_nonces" TO "authenticated";
GRANT ALL ON TABLE "public"."wallet_nonces" TO "service_role";



GRANT ALL ON TABLE "public"."wallet_sync_state" TO "anon";
GRANT ALL ON TABLE "public"."wallet_sync_state" TO "authenticated";
GRANT ALL ON TABLE "public"."wallet_sync_state" TO "service_role";



GRANT ALL ON TABLE "public"."wallet_transaction" TO "anon";
GRANT ALL ON TABLE "public"."wallet_transaction" TO "authenticated";
GRANT ALL ON TABLE "public"."wallet_transaction" TO "service_role";



GRANT ALL ON SEQUENCE "public"."wallet_transactions_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."wallet_transactions_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."wallet_transactions_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."wallet_tx_with_flags" TO "anon";
GRANT ALL ON TABLE "public"."wallet_tx_with_flags" TO "authenticated";
GRANT ALL ON TABLE "public"."wallet_tx_with_flags" TO "service_role";



GRANT ALL ON TABLE "public"."wallets" TO "anon";
GRANT ALL ON TABLE "public"."wallets" TO "authenticated";
GRANT ALL ON TABLE "public"."wallets" TO "service_role";









ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "service_role";






ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "service_role";






ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "service_role";































